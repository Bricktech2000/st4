$ cp st1.c st2.c
$ bin/st1 Makefile
10n
1:st1:
2:	mkdir -p bin
3:	gcc -O2 -Wall -Werror -pedantic -std=c99 st1.c -o bin/st1
4:
5:clean:
6:	rm -rf bin
7:8:9:10:3g4a
st2:
	mkdir -p bin
	gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
wq
$ bin/st2 Makefile
10n
1:st1:
2:	mkdir -p bin
3:	gcc -O2 -Wall -Werror -pedantic -std=c99 st1.c -o bin/st1
4:
5:st2:
6:	mkdir -p bin
7:	gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
8:
9:clean:
10:	rm -rf bin
q
$ bin/st2 st2.c
99n
1:#include <stdio.h>
2:#include <string.h>
3:
4:unsigned nlines = 0;
5:unsigned curr = 0;
6:char lines[65536][256] = {0};
7:
8:int main(int argc, char **argv) {
9:  FILE *fp = fopen(argv[1], "r+");
10:
11:  ungetc('r', stdin);
12:  while(!feof(stdin)) {
13:    unsigned cnt;
14:    if (scanf("%u", &cnt) != 1)
15:      cnt = 1;
16:
17:    char cmd;
18:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdnprwq", cmd)) {
19:      printf("?\n");
20:      continue;
21:    }
22:
23:    switch (cmd) {
24:    case 'g':
25:      curr = cnt - 1;
26:      break;
27:    case 'j':
28:      curr += cnt;
29:      break;
30:    case 'k':
31:      curr -= cnt;
32:      break;
33:    case 'd':
34:      nlines -= cnt;
35:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
36:      memset(lines[nlines], 0, cnt * sizeof(*lines));
37:      break;
38:    case 'a':
39:      curr++;
40:    case 'i':
41:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
42:      nlines += cnt;
43:      break;
44:    case 'r':
45:    case 'w':
46:      rewind(fp);
47:      break;
48:    case 'q':
49:      goto exit;
50:    }
51:
52:    for (unsigned n = 0; n < cnt; n++) {
53:      switch (cmd) {
54:      case 'a':
55:      case 'i':
56:      case 'c':
57:        fgets(lines[curr + n], sizeof(*lines), stdin);
58:        break;
59:      case 'n':
60:        printf("%u:", curr + n + 1);
61:      case 'p':
62:        fputs(lines[curr + n], stdout);
63:        break;
64:      case 'r':
65:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
66:          cnt++;
67:        nlines = cnt;
68:        break;
69:      case 'w':
70:        cnt = nlines;
71:        fputs(lines[n], fp);
72:        break;
73:      }
74:    }
75:  }
76:
77:exit:
78:  fclose(fp);
79:}
80:
81:
82:
83:
84:
85:
86:
87:
88:
89:
90:
91:
92:
93:
94:
95:
96:
97:
98:
99:
5gd4giunsigned curr = 0;
g20n
1:#include <stdio.h>
2:#include <string.h>
3:
4:unsigned curr = 0;
5:unsigned nlines = 0;
6:char lines[65536][256] = {0};
7:
8:int main(int argc, char **argv) {
9:  FILE *fp = fopen(argv[1], "r+");
10:
11:  ungetc('r', stdin);
12:  while(!feof(stdin)) {
13:    unsigned cnt;
14:    if (scanf("%u", &cnt) != 1)
15:      cnt = 1;
16:
17:    char cmd;
18:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdnprwq", cmd)) {
19:      printf("?\n");
20:      continue;
6g2aunsigned ncut = 0;
char cut[256][256] = {0};
20g40n
20:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdnprwq", cmd)) {
21:      printf("?\n");
22:      continue;
23:    }
24:
25:    switch (cmd) {
26:    case 'g':
27:      curr = cnt - 1;
28:      break;
29:    case 'j':
30:      curr += cnt;
31:      break;
32:    case 'k':
33:      curr -= cnt;
34:      break;
35:    case 'd':
36:      nlines -= cnt;
37:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
38:      memset(lines[nlines], 0, cnt * sizeof(*lines));
39:      break;
40:    case 'a':
41:      curr++;
42:    case 'i':
43:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
44:      nlines += cnt;
45:      break;
46:    case 'r':
47:    case 'w':
48:      rewind(fp);
49:      break;
50:    case 'q':
51:      goto exit;
52:    }
53:
54:    for (unsigned n = 0; n < cnt; n++) {
55:      switch (cmd) {
56:      case 'a':
57:      case 'i':
58:      case 'c':
59:        fgets(lines[curr + n], sizeof(*lines), stdin);
20gc    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnprwq", cmd)) {
w
45ga    case 'y':
a      memcpy(*cut, lines[curr], cnt * sizeof(*lines));
i      ncut = cnt;
w
20g40n
20:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnprwq", cmd)) {
21:      printf("?\n");
22:      continue;
23:    }
24:
25:    switch (cmd) {
26:    case 'g':
27:      curr = cnt - 1;
28:      break;
29:    case 'j':
30:      curr += cnt;
31:      break;
32:    case 'k':
33:      curr -= cnt;
34:      break;
35:    case 'd':
36:      nlines -= cnt;
37:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
38:      memset(lines[nlines], 0, cnt * sizeof(*lines));
39:      break;
40:    case 'a':
41:      curr++;
42:    case 'i':
43:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
44:      nlines += cnt;
45:      break;
46:    case 'y':
47:      ncut = cnt;
48:      memcpy(*cut, lines[curr], cnt * sizeof(*lines));
49:    case 'r':
50:    case 'w':
51:      rewind(fp);
52:      break;
53:    case 'q':
54:      goto exit;
55:    }
56:
57:    for (unsigned n = 0; n < cnt; n++) {
58:      switch (cmd) {
59:      case 'a':
48ga      break;
w
57g20n
57:
58:    for (unsigned n = 0; n < cnt; n++) {
59:      switch (cmd) {
60:      case 'a':
61:      case 'i':
62:      case 'c':
63:        fgets(lines[curr + n], sizeof(*lines), stdin);
64:        break;
65:      case 'n':
66:        printf("%u:", curr + n + 1);
67:      case 'p':
68:        fputs(lines[curr + n], stdout);
69:        break;
70:      case 'r':
71:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
72:          cnt++;
73:        nlines = cnt;
74:        break;
75:      case 'w':
76:        cnt = nlines;
40n
57:
58:    for (unsigned n = 0; n < cnt; n++) {
59:      switch (cmd) {
60:      case 'a':
61:      case 'i':
62:      case 'c':
63:        fgets(lines[curr + n], sizeof(*lines), stdin);
64:        break;
65:      case 'n':
66:        printf("%u:", curr + n + 1);
67:      case 'p':
68:        fputs(lines[curr + n], stdout);
69:        break;
70:      case 'r':
71:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
72:          cnt++;
73:        nlines = cnt;
74:        break;
75:      case 'w':
76:        cnt = nlines;
77:        fputs(lines[n], fp);
78:        break;
79:      }
80:    }
81:  }
82:
83:exit:
84:  fclose(fp);
85:}
86:
87:
88:
89:
90:
91:
92:
93:
94:
95:
96:
69g
a      case 'x':
a        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*lines));
c        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
a        break;
45g4n
45:      break;
46:    case 'y':
47:      ncut = cnt;
48:      memcpy(*cut, lines[curr], cnt * sizeof(*lines));
48gc      memcpy(*cut, lines[curr], cnt * sizeof(*cut));
w
kk4n
46:    case 'y':
47:      ncut = cnt;
48:      memcpy(*cut, lines[curr], cnt * sizeof(*cut));
49:      break;
49g8n
49:      break;
50:    case 'r':
51:    case 'w':
52:      rewind(fp);
53:      break;
54:    case 'q':
55:      goto exit;
56:    }
a    case 'x':
a      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
a      nlines += cnt * ncut;
w
q
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
99n
1:#include <stdio.h>
2:#include <string.h>
3:
4:unsigned curr = 0;
5:unsigned nlines = 0;
6:char lines[65536][256] = {0};
7:unsigned ncut = 0;
8:char cut[256][256] = {0};
9:
10:int main(int argc, char **argv) {
11:  FILE *fp = fopen(argv[1], "r+");
12:
13:  ungetc('r', stdin);
14:  while(!feof(stdin)) {
15:    unsigned cnt;
16:    if (scanf("%u", &cnt) != 1)
17:      cnt = 1;
18:
19:    char cmd;
20:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnprwq", cmd)) {
21:      printf("?\n");
22:      continue;
23:    }
24:
25:    switch (cmd) {
26:    case 'g':
27:      curr = cnt - 1;
28:      break;
29:    case 'j':
30:      curr += cnt;
31:      break;
32:    case 'k':
33:      curr -= cnt;
34:      break;
35:    case 'd':
36:      nlines -= cnt;
37:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
38:      memset(lines[nlines], 0, cnt * sizeof(*lines));
39:      break;
40:    case 'a':
41:      curr++;
42:    case 'i':
43:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
44:      nlines += cnt;
45:      break;
46:    case 'y':
47:      ncut = cnt;
48:      memcpy(*cut, lines[curr], cnt * sizeof(*cut));
49:      break;
50:    case 'x':
51:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
52:      nlines += cnt * ncut;
53:    case 'r':
54:    case 'w':
55:      rewind(fp);
56:      break;
57:    case 'q':
58:      goto exit;
59:    }
60:
61:    for (unsigned n = 0; n < cnt; n++) {
62:      switch (cmd) {
63:      case 'a':
64:      case 'i':
65:      case 'c':
66:        fgets(lines[curr + n], sizeof(*lines), stdin);
67:        break;
68:      case 'n':
69:        printf("%u:", curr + n + 1);
70:      case 'p':
71:        fputs(lines[curr + n], stdout);
72:        break;
73:      case 'x':
74:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
75:        break;
76:      case 'r':
77:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
78:          cnt++;
79:        nlines = cnt;
80:        break;
81:      case 'w':
82:        cnt = nlines;
83:        fputs(lines[n], fp);
84:        break;
85:      }
86:    }
87:  }
88:
89:exit:
90:  fclose(fp);
91:}
92:
93:
94:
95:
96:
97:
98:
99:
48gp
      memcpy(*cut, lines[curr], cnt * sizeof(*cut));
c      memcpy(*cut, lines[curr], ncut * sizeof(*cut));
46gi    case 'c':
48gp
      ncut = cnt;
40g20n
40:    case 'a':
41:      curr++;
42:    case 'i':
43:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
44:      nlines += cnt;
45:      break;
46:    case 'c':
47:    case 'y':
48:      ncut = cnt;
49:      memcpy(*cut, lines[curr], ncut * sizeof(*cut));
50:      break;
51:    case 'x':
52:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
53:      nlines += cnt * ncut;
54:    case 'r':
55:    case 'w':
56:      rewind(fp);
57:      break;
58:    case 'q':
59:      goto exit;
48gd
c      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
w
y
35gx
30g30n
30:      curr += cnt;
31:      break;
32:    case 'k':
33:      curr -= cnt;
34:      break;
35:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
36:    case 'd':
37:      nlines -= cnt;
38:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
39:      memset(lines[nlines], 0, cnt * sizeof(*lines));
40:      break;
41:    case 'a':
42:      curr++;
43:    case 'i':
44:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
45:      nlines += cnt;
46:      break;
47:    case 'c':
48:    case 'y':
49:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
50:      break;
51:    case 'x':
52:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
53:      nlines += cnt * ncut;
54:    case 'r':
55:    case 'w':
56:      rewind(fp);
57:      break;
58:    case 'q':
59:      goto exit;
47gdwq
$ bin/st2 st2.c
35gp
      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
d
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
99n
1:#include <stdio.h>
2:#include <string.h>
3:
4:unsigned curr = 0;
5:unsigned nlines = 0;
6:char lines[65536][256] = {0};
7:unsigned ncut = 0;
8:char cut[256][256] = {0};
9:
10:int main(int argc, char **argv) {
11:  FILE *fp = fopen(argv[1], "r+");
12:
13:  ungetc('r', stdin);
14:  while(!feof(stdin)) {
15:    unsigned cnt;
16:    if (scanf("%u", &cnt) != 1)
17:      cnt = 1;
18:
19:    char cmd;
20:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnprwq", cmd)) {
21:      printf("?\n");
22:      continue;
23:    }
24:
25:    switch (cmd) {
26:    case 'g':
27:      curr = cnt - 1;
28:      break;
29:    case 'j':
30:      curr += cnt;
31:      break;
32:    case 'k':
33:      curr -= cnt;
34:      break;
35:    case 'd':
36:      nlines -= cnt;
37:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
38:      memset(lines[nlines], 0, cnt * sizeof(*lines));
39:      break;
40:    case 'a':
41:      curr++;
42:    case 'i':
43:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
44:      nlines += cnt;
45:      break;
46:    case 'y':
47:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
48:      break;
49:    case 'x':
50:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
51:      nlines += cnt * ncut;
52:    case 'r':
53:    case 'w':
54:      rewind(fp);
55:      break;
56:    case 'q':
57:      goto exit;
58:    }
59:
60:    for (unsigned n = 0; n < cnt; n++) {
61:      switch (cmd) {
62:      case 'a':
63:      case 'i':
64:      case 'c':
65:        fgets(lines[curr + n], sizeof(*lines), stdin);
66:        break;
67:      case 'n':
68:        printf("%u:", curr + n + 1);
69:      case 'p':
70:        fputs(lines[curr + n], stdout);
71:        break;
72:      case 'x':
73:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
74:        break;
75:      case 'r':
76:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
77:          cnt++;
78:        nlines = cnt;
79:        break;
80:      case 'w':
81:        cnt = nlines;
82:        fputs(lines[n], fp);
83:        break;
84:      }
85:    }
86:  }
87:
88:exit:
89:  fclose(fp);
90:}
91:
92:
93:
94:
95:
96:
97:
98:
99:
20gp
    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnprwq", cmd)) {
c    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyqnpewq", cmd)) {
52gc    case 'e':
75gc      case 'e':
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
?
e
13gc  ungetc('e', stdin);
w
1ga#include <stdlib.h>
11g
a  if (argc != 2)
a    fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
g16n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:unsigned curr = 0;
6:unsigned nlines = 0;
7:char lines[65536][256] = {0};
8:unsigned ncut = 0;
9:char cut[256][256] = {0};
10:
11:int main(int argc, char **argv) {
12:  if (argc != 2)
13:    fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
14:  FILE *fp = fopen(argv[1], "r+");
15:
16:  ungetc('e', stdin);
13a
   





























g
30p
#include <stdio.h>













#include <stdlib.h>
#include <string.h>

unsigned curr = 0;
unsigned nlines = 0;
char lines[65536][256] = {0};
unsigned ncut = 0;
char cut[256][256] = {0};

int main(int argc, char **argv) {
  if (argc != 2)
    fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
  FILE *fp = fopen(argv[1], "r+");

  ungetc('e', stdin);
  while(!feof(stdin)) {
2g10dg10n
1:#include <stdio.h>
2:
3:
4:
5:#include <stdlib.h>
6:#include <string.h>
7:
8:unsigned curr = 0;
9:unsigned nlines = 0;
10:char lines[65536][256] = {0};
2g3d
g16n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:unsigned curr = 0;
6:unsigned nlines = 0;
7:char lines[65536][256] = {0};
8:unsigned ncut = 0;
9:char cut[256][256] = {0};
10:
11:int main(int argc, char **argv) {
12:  if (argc != 2)
13:    fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
14:  FILE *fp = fopen(argv[1], "r+");
15:
16:  ungetc('e', stdin);
13ga
15ga  if (fp == NULL)
   a    perror("fopen"), exit(EXIT_FAILURE);
w
g16n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:unsigned curr = 0;
6:unsigned nlines = 0;
7:char lines[65536][256] = {0};
8:unsigned ncut = 0;
9:char cut[256][256] = {0};
10:
11:int main(int argc, char **argv) {
12:  if (argc != 2)
13:    fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
14:
15:  FILE *fp = fopen(argv[1], "r+");
16:  if (fp == NULL)
20n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:unsigned curr = 0;
6:unsigned nlines = 0;
7:char lines[65536][256] = {0};
8:unsigned ncut = 0;
9:char cut[256][256] = {0};
10:
11:int main(int argc, char **argv) {
12:  if (argc != 2)
13:    fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
14:
15:  FILE *fp = fopen(argv[1], "r+");
16:  if (fp == NULL)
17:    perror("fopen"), exit(EXIT_FAILURE);
18:
19:  ungetc('e', stdin);
20:  while(!feof(stdin)) {
80g20n
80:        break;
81:      case 'e':
82:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
83:          cnt++;
84:        nlines = cnt;
85:        break;
86:      case 'w':
87:        cnt = nlines;
88:        fputs(lines[n], fp);
89:        break;
90:      }
91:    }
92:  }
93:
94:exit:
95:  fclose(fp);
96:}
97:
98:
99:
95gc  if (fclose(fp) == EOF))
a    perror("fclose"), exit(EXIT_FAILURE);
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:13:11: error: passing argument 1 of ‘fputs’ from incompatible pointer type [-Werror=incompatible-pointer-types]
   13 |     fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
      |           ^~~~~~
      |           |
      |           FILE *
In file included from st2.c:1:
/nix/store/lw5b7x8wndk7sdis78r2f8fy12ldmpwc-glibc-2.37-45-dev/include/stdio.h:655:42: note: expected ‘const char * restrict’ but argument is of type ‘FILE *’
  655 | extern int fputs (const char *__restrict __s, FILE *__restrict __stream);
      |                   ~~~~~~~~~~~~~~~~~~~~~~~^~~
st2.c:13:19: error: passing argument 2 of ‘fputs’ from incompatible pointer type [-Werror=incompatible-pointer-types]
   13 |     fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
      |                   ^~~~~~~~~~~~~~~~~~~~~~~~~
      |                   |
      |                   char *
/nix/store/lw5b7x8wndk7sdis78r2f8fy12ldmpwc-glibc-2.37-45-dev/include/stdio.h:655:64: note: expected ‘FILE * restrict’ but argument is of type ‘char *’
  655 | extern int fputs (const char *__restrict __s, FILE *__restrict __stream);
      |                                               ~~~~~~~~~~~~~~~~~^~~~~~~~
st2.c:95:25: error: expected statement before ‘)’ token
   95 |   if (fclose(fp) == EOF))
      |                         ^
cc1: all warnings being treated as errors
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
?
e
99gc  if (fclose (fp) == EOF)
13gp
    fputs(stdout, "Usage: st2 <filename>\n"), exit(EXIT_FAILURE);
c    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:95:25: error: expected statement before ‘)’ token
   95 |   if (fclose(fp) == EOF))
      |                         ^
st2.c: At top level:
st2.c:99:3: error: expected identifier or ‘(’ before ‘if’
   99 |   if (fclose (fp) == EOF)
      |   ^~
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
?
e
99gd95gc  if (fclose(fp) == EOF)
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
26gp
    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyqnpewq", cmd)) {
c    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnpewq", cmd)) {
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
30n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:unsigned curr = 0;
6:unsigned nlines = 0;
7:char lines[65536][256] = {0};
8:unsigned ncut = 0;
9:char cut[256][256] = {0};
10:
11:int main(int argc, char **argv) {
12:  if (argc != 2)
13:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
14:
15:  FILE *fp = fopen(argv[1], "r+");
16:  if (fp == NULL)
17:    perror("fopen"), exit(EXIT_FAILURE);
18:
19:  ungetc('e', stdin);
20:  while(!feof(stdin)) {
21:    unsigned cnt;
22:    if (scanf("%u", &cnt) != 1)
23:      cnt = 1;
24:
25:    char cmd;
26:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnpewq", cmd)) {
27:      printf("?\n");
28:      continue;
29:    }
30:
3ga
a// g - go to line number N
a// j - move down N lines
a// k - move up N lines
a// a - append N new lines below
a// i - insert N new lines above
a// c - rewrite contents of N lines
a// d - delete N lines
c// d - delete next N lines
a// y - copy next N lines
a// x - paste above N times
a// n - print next N lines numbered
a// p - print next N lines
a// e - re-read file from disk
c// e - read file from disk
a// w - write file to disk
a// q - quit without confirmation
g20n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite contents of N lines
11:// d - delete next N lines
12:// y - copy next N lines
13:// x - paste above N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
10gc// rewrite next N lines
g30n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// rewrite next N lines
11:// d - delete next N lines
12:// y - copy next N lines
13:// x - paste above N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
10gc// c - rewrite next N lines
g30n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - copy next N lines
13:// x - paste above N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
13gc// x - paste last yank N times
g30n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - copy next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
12gc// y - yank (copy) next N lines
g20n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
wq
$ bin/st2 st2.c
99n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  ungetc('e', stdin);
35:  while(!feof(stdin)) {
36:    unsigned cnt;
37:    if (scanf("%u", &cnt) != 1)
38:      cnt = 1;
39:
40:    char cmd;
41:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnpewq", cmd)) {
42:      printf("?\n");
43:      continue;
44:    }
45:
46:    switch (cmd) {
47:    case 'g':
48:      curr = cnt - 1;
49:      break;
50:    case 'j':
51:      curr += cnt;
52:      break;
53:    case 'k':
54:      curr -= cnt;
55:      break;
56:    case 'd':
57:      nlines -= cnt;
58:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
59:      memset(lines[nlines], 0, cnt * sizeof(*lines));
60:      break;
61:    case 'a':
62:      curr++;
63:    case 'i':
64:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
65:      nlines += cnt;
66:      break;
67:    case 'y':
68:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
69:      break;
70:    case 'x':
71:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
72:      nlines += cnt * ncut;
73:    case 'e':
74:    case 'w':
75:      rewind(fp);
76:      break;
77:    case 'q':
78:      goto exit;
79:    }
80:
81:    for (unsigned n = 0; n < cnt; n++) {
82:      switch (cmd) {
83:      case 'a':
84:      case 'i':
85:      case 'c':
86:        fgets(lines[curr + n], sizeof(*lines), stdin);
87:        break;
88:      case 'n':
89:        printf("%u:", curr + n + 1);
90:      case 'p':
91:        fputs(lines[curr + n], stdout);
92:        break;
93:      case 'x':
94:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
95:        break;
96:      case 'e':
97:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
98:          cnt++;
99:        nlines = cnt;
32ga
a  char buf[64];
a  char *bufp = buf;
a  int nread;
32gcchar buf[64], *bufp = buf;
33gd
30g8n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:char buf[64], *bufp = buf;
33:  char buf[64];
34:  char *bufp = buf;
35:  int nread;
36:
37:  ungetc('e', stdin);
32gc  char buf[64], *bufp = buf;
i    cnt = 1;
a
30g9n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    cnt = 1;
33:
34:  char buf[64], *bufp = buf;
35:  char buf[64];
36:  char *bufp = buf;
37:  int nread;
38:
35g2d30g8n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    cnt = 1;
33:
34:  char buf[64], *bufp = buf;
35:  int nread;
36:
37:  ungetc('e', stdin);
38gp
  while(!feof(stdin)) {
a    if (*bufp == '\0') {
a      bufp = fgets(buf, sizeof(buf), stdin);
39gc    if (*bufp == '\0)
30g10n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    cnt = 1;
33:
34:  char buf[64], *bufp = buf;
35:  int nread;
36:
37:  ungetc('e', stdin);
38:  while(!feof(stdin)) {
39:    if (*bufp == '\0)
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    cnt = 1;
33:
34:  char buf[64], *bufp = buf;
35:  int nread;
36:
37:  ungetc('e', stdin);
38:  while(!feof(stdin)) {
39:    if (*bufp == '\0)
40:      bufp = fgets(buf, sizeof(buf), stdin);
41:    unsigned cnt;
42:    if (scanf("%u", &cnt) != 1)
43:      cnt = 1;
44:
45:    char cmd;
46:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnpewq", cmd)) {
47:      printf("?\n");
48:      continue;
49:    }
32gc    perror("fopen"), exit(EXIT_FAILURE);
40ga
a    int nread;
a    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64], *bufp = buf;
35:  int nread;
36:
37:  ungetc('e', stdin);
38:  while(!feof(stdin)) {
39:    if (*bufp == '\0)
40:      bufp = fgets(buf, sizeof(buf), stdin);
41:
42:    int nread;
43:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
44:    unsigned cnt;
45:    if (scanf("%u", &cnt) != 1)
46:      cnt = 1;
47:
48:    char cmd;
49:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnpewq", cmd)) {
w
35gd
c  *buf = '\0';
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64], *bufp = buf;
35:  *buf = '\0';
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp == '\0)
39:      bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread;
42:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
43:    unsigned cnt;
44:    if (scanf("%u", &cnt) != 1)
45:      cnt = 1;
46:
47:    char cmd;
48:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnpewq", cmd)) {
49:      printf("?\n");
34gc  char buf[64] = {0}, *bufp = buf;
35gc
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp == '\0)
39:      bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread;
42:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
43:    unsigned cnt;
44:    if (scanf("%u", &cnt) != 1)
45:      cnt = 1;
46:
47:    char cmd;
48:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnpewq", cmd)) {
49:      printf("?\n");
43g2da    bufp += nread;
40g20n
40:
41:    int nread;
42:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
43:      cnt = 1;
44:    bufp += nread;
45:
46:    char cmd;
47:    if (scanf("%c", &cmd) != 1 || !strchr("gjkaicdyxnpewq", cmd)) {
48:      printf("?\n");
49:      continue;
50:    }
51:
52:    switch (cmd) {
53:    case 'g':
54:      curr = cnt - 1;
55:      break;
56:    case 'j':
57:      curr += cnt;
58:      break;
59:    case 'k':
w
46gd
c    if (!strchr("gjkaicdyxnpewq", *bufp++)) {
40g20n
40:
41:    int nread;
42:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
43:      cnt = 1;
44:    bufp += nread;
45:
46:    if (!strchr("gjkaicdyxnpewq", *bufp++)) {
47:      printf("?\n");
48:      continue;
49:    }
50:
51:    switch (cmd) {
52:    case 'g':
53:      curr = cnt - 1;
54:      break;
55:    case 'j':
56:      curr += cnt;
57:      break;
58:    case 'k':
59:      curr -= cnt;
w
q
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:38:18: error: missing terminating ' character [-Werror]
   38 |     if (*bufp == '\0)
      |                  ^
st2.c:38:18: error: missing terminating ' character
   38 |     if (*bufp == '\0)
      |                  ^~~~
st2.c:38:15: error: comparison between pointer and integer [-Werror]
   38 |     if (*bufp == '\0)
      |               ^~
st2.c:39:12: error: lvalue required as left operand of assignment
   39 |       bufp = fgets(buf, sizeof(buf), stdin);
      |            ^
st2.c:39:44: error: expected ‘)’ before ‘;’ token
   39 |       bufp = fgets(buf, sizeof(buf), stdin);
      |                                            ^
      |                                            )
st2.c:38:8: note: to match this ‘(’
   38 |     if (*bufp == '\0)
      |        ^
st2.c:112:3: error: expected expression before ‘}’ token
  112 |   }
      |   ^
st2.c:114:1: error: label ‘exit’ defined but not used [-Werror=unused-label]
  114 | exit:
      | ^~~~
cc1: all warnings being treated as errors
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
38gp
    if (*bufp == '\0)
c    if (*bufp == '\0')
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:42:31: error: ‘cnt’ undeclared (first use in this function); did you mean ‘cut’?
   42 |     if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
      |                               ^~~
      |                               cut
st2.c:42:31: note: each undeclared identifier is reported only once for each function it appears in
st2.c:51:13: error: ‘cmd’ undeclared (first use in this function)
   51 |     switch (cmd) {
      |             ^~~
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
42gkkkk8n
38:    if (*bufp == '\0')
39:      bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread;
42:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
43:      cnt = 1;
44:    bufp += nread;
45:
41ga    unsigned cnt = 1;
c    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
38g8n
38:    if (*bufp == '\0')
39:      bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread;
42:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
43:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
44:      cnt = 1;
45:    bufp += nread;
43gddd38g10n
38:    if (*bufp == '\0')
39:      bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread;
42:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
43:
44:    if (!strchr("gjkaicdyxnpewq", *bufp++)) {
45:      printf("?\n");
46:      continue;
47:    }
41ga    unsigned cnt = 1;
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:50:13: error: ‘cmd’ undeclared (first use in this function)
   50 |     switch (cmd) {
      |             ^~~
st2.c:50:13: note: each undeclared identifier is reported only once for each function it appears in
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
50gkkk8n
47:      continue;
48:    }
49:
50:    switch (cmd) {
51:    case 'g':
52:      curr = cnt - 1;
53:      break;
54:    case 'j':
50gc    switch (*bufp) {
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:86:15: error: ‘cmd’ undeclared (first use in this function)
   86 |       switch (cmd) {
      |               ^~~
st2.c:86:15: note: each undeclared identifier is reported only once for each function it appears in
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
86gp
      switch (cmd) {
c      switch (*bufp) {
wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
99n
?

k
?
^C
! bin/st2 st2.c
99n
?
99p
^C
! v st2.c 
$ bin/st1 st2.c
20n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
20g20n
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp == '\0')
39:      bufp = fgets(buf, sizeof(buf), stdin);
37ga    putchar(':');
20g20n
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    putchar(':');
39:    if (*bufp == '\0')
38gd30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp == '\0')
39:      bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread;
42:    unsigned cnt = 1;
43:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
44:
45:    if (!strchr("gjkaicdyxnpewq", *bufp++)) {
46:      printf("?\n");
47:      continue;
48:    }
49:
39gc      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp == '\0')
39:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread;
42:    unsigned cnt = 1;
43:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
44:
45:    if (!strchr("gjkaicdyxnpewq", *bufp++)) {
46:      printf("?\n");
47:      continue;
48:    }
49:
41gc    int nread = 0;
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
:99n
?
:99nn
1:2:3:4:5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:22:23:24:25:26:27:28:29:30:31:32:33:34:35:36:37:38:39:40:41:42:43:44:45:46:47:48:49:50:51:52:53:54:55:56:57:58:59:60:61:62:63:64:65:66:67:68:69:70:71:72:73:74:75:76:77:78:79:80:81:82:83:84:85:86:87:88:89:90:91:92:93:94:95:96:97:98:99:?
:e
?
:ee
?
:1e
?
:1ee
?
:q 
?
:fish: Job 1, 'bin/st2 st2.c' terminated by signal SIGSEGV (Address boundary error)
! bin/st1 st2.c
20g20n
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp == '\0')
39:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp == '\0')
39:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread = 0;
42:    unsigned cnt = 1;
43:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
44:
45:    if (!strchr("gjkaicdyxnpewq", *bufp++)) {
46:      printf("?\n");
47:      continue;
48:    }
49:
38gc    if (*bufp++ == '\0')               
45gc    if (!strchr("gjkaicdyxnpewq", *bufp)) {
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
:99n 
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp++ == '\0')
39:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread = 0;
42:    unsigned cnt = 1;
43:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
44:
45:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
46:      printf("?\n");
47:      continue;
48:    }
49:
50:    switch (*bufp) {
51:    case 'g':
52:      curr = cnt - 1;
53:      break;
54:    case 'j':
55:      curr += cnt;
56:      break;
57:    case 'k':
58:      curr -= cnt;
59:      break;
60:    case 'd':
61:      nlines -= cnt;
62:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
63:      memset(lines[nlines], 0, cnt * sizeof(*lines));
64:      break;
65:    case 'a':
66:      curr++;
67:    case 'i':
68:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
69:      nlines += cnt;
70:      break;
71:    case 'y':
72:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
73:      break;
74:    case 'x':
75:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
76:      nlines += cnt * ncut;
77:    case 'e':
78:    case 'w':
79:      rewind(fp);
80:      break;
81:    case 'q':
82:      goto exit;
83:    }
84:
85:    for (unsigned n = 0; n < cnt; n++) {
86:      switch (*bufp) {
87:      case 'a':
88:      case 'i':
89:      case 'c':
90:        fgets(lines[curr + n], sizeof(*lines), stdin);
91:        break;
92:      case 'n':
93:        printf("%u:", curr + n + 1);
94:      case 'p':
95:        fputs(lines[curr + n], stdout);
96:        break;
97:      case 'x':
98:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
99:        break;
?
:38gc    if (*bufp++ == '\n') 
^C⏎                                                                                                                     ! bin/st2 st2.c
:38gc
    if (*bufp++ = '\n')
?
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:38:9: error: suggest parentheses around assignment used as truth value [-Werror=parentheses]
   38 |     if (*bufp++ = '\n')
      |         ^
cc1: all warnings being treated as errors
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
:38gc
    if (*bufp++ == '\n')
?
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
:q
$ bin/st1 st2.c
38gkk8n
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
38:    if (*bufp++ == '\n')
39:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread = 0;
42:    unsigned cnt = 1;
43:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
30g8n   
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = {0}, *bufp = buf;
35:
36:  ungetc('e', stdin);
37:  while(!feof(stdin)) {
34gc  char buf[64] = { 'e', '\n', 0 };
a  char *bufp = buf;
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
?
:99n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf;
36:
37:  ungetc('e', stdin);
38:  while(!feof(stdin)) {
39:    if (*bufp++ == '\n')
40:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
41:
42:    int nread = 0;
43:    unsigned cnt = 1;
44:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
45:
46:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
47:      printf("?\n");
48:      continue;
49:    }
50:
51:    switch (*bufp) {
52:    case 'g':
53:      curr = cnt - 1;
54:      break;
55:    case 'j':
56:      curr += cnt;
57:      break;
58:    case 'k':
59:      curr -= cnt;
60:      break;
61:    case 'd':
62:      nlines -= cnt;
63:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
64:      memset(lines[nlines], 0, cnt * sizeof(*lines));
65:      break;
66:    case 'a':
67:      curr++;
68:    case 'i':
69:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
70:      nlines += cnt;
71:      break;
72:    case 'y':
73:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
74:      break;
75:    case 'x':
76:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
77:      nlines += cnt * ncut;
78:    case 'e':
79:    case 'w':
80:      rewind(fp);
81:      break;
82:    case 'q':
83:      goto exit;
84:    }
85:
86:    for (unsigned n = 0; n < cnt; n++) {
87:      switch (*bufp) {
88:      case 'a':
89:      case 'i':
90:      case 'c':
91:        fgets(lines[curr + n], sizeof(*lines), stdin);
92:        break;
93:      case 'n':
94:        printf("%u:", curr + n + 1);
95:      case 'p':
96:        fputs(lines[curr + n], stdout);
97:        break;
98:      case 'x':
99:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
?
:39gc
    if (++*bufp == '\n')
?
:35gc
  char *bufp = buf, bufp--;
?
:37gd
?
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:35:25: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘--’ token
   35 |   char *bufp = buf, bufp--;
      |                         ^~
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
?
:35gc
  char *bufp = buf - 1; // for 'e'
?
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
99n
10n
g
e
^C
! bin/st1 st2.c
120n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf - 1; // for 'e'
36:
37:  while(!feof(stdin)) {
38:    if (++*bufp == '\n')
39:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
40:
41:    int nread = 0;
42:    unsigned cnt = 1;
43:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
44:
45:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
46:      printf("?\n");
47:      continue;
48:    }
49:
50:    switch (*bufp) {
51:    case 'g':
52:      curr = cnt - 1;
53:      break;
54:    case 'j':
55:      curr += cnt;
56:      break;
57:    case 'k':
58:      curr -= cnt;
59:      break;
60:    case 'd':
61:      nlines -= cnt;
62:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
63:      memset(lines[nlines], 0, cnt * sizeof(*lines));
64:      break;
65:    case 'a':
66:      curr++;
67:    case 'i':
68:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
69:      nlines += cnt;
70:      break;
71:    case 'y':
72:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
73:      break;
74:    case 'x':
75:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
76:      nlines += cnt * ncut;
77:    case 'e':
78:    case 'w':
79:      rewind(fp);
80:      break;
81:    case 'q':
82:      goto exit;
83:    }
84:
85:    for (unsigned n = 0; n < cnt; n++) {
86:      switch (*bufp) {
87:      case 'a':
88:      case 'i':
89:      case 'c':
90:        fgets(lines[curr + n], sizeof(*lines), stdin);
91:        break;
92:      case 'n':
93:        printf("%u:", curr + n + 1);
94:      case 'p':
95:        fputs(lines[curr + n], stdout);
96:        break;
97:      case 'x':
98:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
99:        break;
100:      case 'e':
101:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
102:          cnt++;
103:        nlines = cnt;
104:        break;
105:      case 'w':
106:        cnt = nlines;
107:        fputs(lines[n], fp);
108:        break;
109:      }
110:    }
111:  }
112:
113:exit:
114:  if (fclose(fp) == EOF)
115:    perror("fclose"), exit(EXIT_FAILURE);
116:}
117:
118:
119:
120:
38gdyd
?
30g10n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf - 1; // for 'e'
36:
37:  while(!feof(stdin)) {
38:
39:    int nread = 0;
38gd
110g20n
110:exit:
111:  if (fclose(fp) == EOF)
112:    perror("fclose"), exit(EXIT_FAILURE);
113:}
114:
115:
116:
117:
118:
119:
120:
121:
122:
123:
124:
125:
126:
127:
128:
129:
100g20n
100:        nlines = cnt;
101:        break;
102:      case 'w':
103:        cnt = nlines;
104:        fputs(lines[n], fp);
105:        break;
106:      }
107:    }
108:  }
109:
110:exit:
111:  if (fclose(fp) == EOF)
112:    perror("fclose"), exit(EXIT_FAILURE);
113:}
114:
115:
116:
117:
118:
119:
107a    if (*bufp++ == '\n')
a      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
35gc  char *bufp = buf;
wq
w
w
$ bin/st1 st2.c
38gddd
107ga    if (*bufp++ == '\n')
a      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
w
?
$ bin/st1 st2.c
100g20n
100:        nlines = cnt;
101:        break;
102:      case 'w':
103:        cnt = nlines;
104:        fputs(lines[n], fp);
105:        break;
106:      }
107:    }
108:    if (*bufp++ == '\n')
109:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
110:  }
111:
112:exit:
113:  if (fclose(fp) == EOF)
114:    perror("fclose"), exit(EXIT_FAILURE);
115:}
116:
117:
118:
119:
107ga
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st1 st2.c
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
^C
! bin/st1 st2.c
108gp

100g20n
100:        nlines = cnt;
101:        break;
102:      case 'w':
103:        cnt = nlines;
104:        fputs(lines[n], fp);
105:        break;
106:      }
107:    }
108:
109:    if (*bufp++ == '\n')
110:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
111:  }
112:
113:exit:
114:  if (fclose(fp) == EOF)
115:    perror("fclose"), exit(EXIT_FAILURE);
116:}
117:
118:
119:
108gddd30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf - 1; // for 'e'
36:
37:  while(!feof(stdin)) {
38:    int nread = 0;
39:    unsigned cnt = 1;
40:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
41:
42:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
43:      printf("?\n");
44:      continue;
45:    }
46:
47:    switch (*bufp) {
48:    case 'g':
49:      curr = cnt - 1;
37ga    if (++*bufp == '\n')
a      putchar(':'), fgets(buf, sizeof(buf), stdin);
a
a    begin:
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf - 1; // for 'e'
36:
37:  while(!feof(stdin)) {
38:    if (++*bufp == '\n')
39:      putchar(':'), fgets(buf, sizeof(buf), stdin);
40:
41:    begin:
42:    int nread = 0;
43:    unsigned cnt = 1;
44:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
45:
46:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
47:      printf("?\n");
48:      continue;
49:    }
41gc  begin:
35ga  goto begin;
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf - 1; // for 'e'
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (++*bufp == '\n')
40:      putchar(':'), fgets(buf, sizeof(buf), stdin);
41:
42:  begin:
43:    int nread = 0;
44:    unsigned cnt = 1;
45:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
46:
47:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
48:      printf("?\n");
49:      continue;
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:43:5: error: a label can only be part of a statement and a declaration is not a statement [-Werror=pedantic]
   43 |     int nread = 0;
      |     ^~~
cc1: all warnings being treated as errors
make: *** [Makefile:7: st2] Error 1
! bin/st1 st2.c
42gp
  begin:
c  begin:;
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c




99n
99n
^C⏎                                                                                                                     ! bin/st1 st2.c
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf - 1; // for 'e'
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (++*bufp == '\n')
40:      putchar(':'), fgets(buf, sizeof(buf), stdin);
41:
42:  begin:;
43:    int nread = 0;
44:    unsigned cnt = 1;
45:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
46:
47:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
48:      printf("?\n");
49:      continue;
40gc      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
99
99n

^C
! bin/st1 st2.c
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf - 1; // for 'e'
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (++*bufp == '\n')
40:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
41:
42:  begin:;
43:    int nread = 0;
44:    unsigned cnt = 1;
45:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
46:
47:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
48:      printf("?\n");
49:      continue;
35gc  char *bufp = buf;
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
?
?
99n
?
?
1:99n
?
99n
$ bin/st1 st2.c
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf;
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (++*bufp == '\n')
40:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
41:
42:  begin:;
43:    int nread = 0;
44:    unsigned cnt = 1;
45:    sscanf(bufp, "%u%n", &cnt, &nread), bufp += nread;
46:
47:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
48:      printf("?\n");
49:      continue;
45gc    if (scanf(bufp, "%u%n", &cnt, &nread) != 1)
a      nread = 0, cnt = 1;
a    bufp += nread;
43gc    int nread;
44gc    unsigned cnt;
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf;
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (++*bufp == '\n')
40:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
41:
42:  begin:;
43:    int nread;
44:    unsigned cnt;
45:    if (scanf(bufp, "%u%n", &cnt, &nread) != 1)
46:      nread = 0, cnt = 1;
47:    bufp += nread;
48:
49:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
^C⏎                                                                                                                     ! bin/st1 st2.c
45gp
    if (scanf(bufp, "%u%n", &cnt, &nread) != 1)
c    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
?
?
^C⏎                                                                                                                     ! bin/st2 st2.c
?
?

?
?
1:
?

$ bin/st1 st2.c
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = { 'e', '\n', 0 };
35:  char *bufp = buf;
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (++*bufp == '\n')
40:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
41:
42:  begin:;
43:    int nread;
44:    unsigned cnt;
45:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
46:      nread = 0, cnt = 1;
47:    bufp += nread;
48:
49:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
34gc  char buf[64] = "e\n";
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
?
?
^C
! bin/st1 st2.c
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = "e\n";
35:  char *bufp = buf;
36:for (int i = 0; i < 64; i++)
37:printf("%x ", buf[i]);
38:goto begin;
39:
40:  while(!feof(stdin)) {
41:    if (++*bufp == '\n')
42:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
43:
44:  begin:;
45:    int nread;
46:    unsigned cnt;
47:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
48:      nread = 0, cnt = 1;
49:    bufp += nread;
36gddc  goto begin;
30g20n
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = "e\n";
35:  char *bufp = buf;
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (++*bufp == '\n')
40:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
41:
42:  begin:;
43:    int nread;
44:    unsigned cnt;
45:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
46:      nread = 0, cnt = 1;
47:    bufp += nread;
48:
49:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
39gc    if (*++bufp == '\n')
w
?
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
:120n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = "e\n";
35:  char *bufp = buf;
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (*++bufp == '\n')
40:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
41:
42:  begin:;
43:    int nread;
44:    unsigned cnt;
45:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
46:      nread = 0, cnt = 1;
47:    bufp += nread;
48:
49:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
50:      printf("?\n");
51:      continue;
52:    }
53:
54:    switch (*bufp) {
55:    case 'g':
56:      curr = cnt - 1;
57:      break;
58:    case 'j':
59:      curr += cnt;
60:      break;
61:    case 'k':
62:      curr -= cnt;
63:      break;
64:    case 'd':
65:      nlines -= cnt;
66:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
67:      memset(lines[nlines], 0, cnt * sizeof(*lines));
68:      break;
69:    case 'a':
70:      curr++;
71:    case 'i':
72:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
73:      nlines += cnt;
74:      break;
75:    case 'y':
76:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
77:      break;
78:    case 'x':
79:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
80:      nlines += cnt * ncut;
81:    case 'e':
82:    case 'w':
83:      rewind(fp);
84:      break;
85:    case 'q':
86:      goto exit;
87:    }
88:
89:    for (unsigned n = 0; n < cnt; n++) {
90:      switch (*bufp) {
91:      case 'a':
92:      case 'i':
93:      case 'c':
94:        fgets(lines[curr + n], sizeof(*lines), stdin);
95:        break;
96:      case 'n':
97:        printf("%u:", curr + n + 1);
98:      case 'p':
99:        fputs(lines[curr + n], stdout);
100:        break;
101:      case 'x':
102:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
103:        break;
104:      case 'e':
105:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
106:          cnt++;
107:        nlines = cnt;
108:        break;
109:      case 'w':
110:        cnt = nlines;
111:        fputs(lines[n], fp);
112:        break;
113:      }
114:    }
115:  }
116:
117:exit:
118:  if (fclose(fp) == EOF)
119:    perror("fclose"), exit(EXIT_FAILURE);
120:}
:97gpca
        printf("%u:", curr + n + 1);
        if (*lines[curr + n])
          printf("%u:", curr + n + 1);
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
:80g40n
80:      nlines += cnt * ncut;
81:    case 'e':
82:    case 'w':
83:      rewind(fp);
84:      break;
85:    case 'q':
86:      goto exit;
87:    }
88:
89:    for (unsigned n = 0; n < cnt; n++) {
90:      switch (*bufp) {
91:      case 'a':
92:      case 'i':
93:      case 'c':
94:        fgets(lines[curr + n], sizeof(*lines), stdin);
95:        break;
96:      case 'n':
97:        if (*lines[curr + n])
98:          printf("%u:", curr + n + 1);
99:      case 'p':
100:        fputs(lines[curr + n], stdout);
101:        break;
102:      case 'x':
103:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
104:        break;
105:      case 'e':
106:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
107:          cnt++;
108:        nlines = cnt;
109:        break;
110:      case 'w':
111:        cnt = nlines;
112:        fputs(lines[n], fp);
113:        break;
114:      }
115:    }
116:  }
117:
118:exit:
119:  if (fclose(fp) == EOF)
:83gc
      fp = fopen(argv[1], "r");
:2a
    case 'w':
      fp = fopen(argv[1], "w");
:54gpi
    switch (*bufp) {
    FILE *fp;
:111g20n
111:        nlines = cnt;
112:        break;
113:      case 'w':
114:        cnt = nlines;
115:        fputs(lines[n], fp);
116:        break;
117:      }
118:    }
119:  }
120:
121:exit:
122:  if (fclose(fp) == EOF)
123:    perror("fclose"), exit(EXIT_FAILURE);
124:}
125:
126:
127:
128:
129:
130:
:118g3a

    switch (*bufp) {
      case 'e':
:118g3c

    if (fp && fclose(fp) == EOF)
      perror("fclose"), exit(EXIT_FAILURE);
:124g8n
124:exit:
125:  if (fclose(fp) == EOF)
126:    perror("fclose"), exit(EXIT_FAILURE);
127:}
128:
129:
130:
131:
:3d
:53gp

:52g4n
52:    }
53:
54:    FILE *fp;
55:    switch (*bufp) {
:54gpc
    FILE *fp;
    FILE *fp = NULL;
:a

:w
:80g6n
80:    case 'x':
81:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
82:      nlines += cnt * ncut;
83:    case 'e':
84:    case 'w':
85:      fp = fopen(argv[1], "r");
:10n
80:    case 'x':
81:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
82:      nlines += cnt * ncut;
83:    case 'e':
84:    case 'w':
85:      fp = fopen(argv[1], "r");
86:    case 'w':
87:      fp = fopen(argv[1], "w");
88:      break;
89:    case 'q':
:84gd
:a
      break;
:80g10n
80:    case 'x':
81:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
82:      nlines += cnt * ncut;
83:    case 'e':
84:      fp = fopen(argv[1], "r");
85:      break;
86:    case 'w':
87:      fp = fopen(argv[1], "w");
88:      break;
89:    case 'q':
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:120:5: error: this ‘if’ clause does not guard... [-Werror=misleading-indentation]
  120 |     if (fp && fclose(fp) == EOF)
      |     ^~
st2.c:122:7: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘if’
  122 |       case 'e':
      |       ^~~~
st2.c:122:7: error: case label not within a switch statement
st2.c:122:12: error: label at end of compound statement [-Werror=pedantic]
  122 |       case 'e':
      |            ^~~
st2.c:125:1: error: expected declaration or statement at end of input
  125 | }
      | ^
st2.c:90:7: error: label ‘exit’ used but not defined
   90 |       goto exit;
      |       ^~~~
cc1: all warnings being treated as errors
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
:90gkkk8n
87:      fp = fopen(argv[1], "w");
88:      break;
89:    case 'q':
90:      goto exit;
91:    }
92:
93:    for (unsigned n = 0; n < cnt; n++) {
94:      switch (*bufp) {
:90gpc
      goto exit;
      return EXIT_SUCCESS;
:125kkkk10n
fish: Job 1, 'bin/st2 st2.c' terminated by signal SIGSEGV (Address boundary error)
! bin/st2 st2.c
:90gc   
      exit(EXIT_SUCCESS); 
:120gkkk10n
117:        break;
118:      }
119:
120:    if (fp && fclose(fp) == EOF)
121:      perror("fclose"), exit(EXIT_FAILURE);
122:      case 'e':
123:  }
124:
125:}
126:
:122gd
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:124:1: error: expected declaration or statement at end of input
  124 | }
      | ^
make: *** [Makefile:7: st2] Error 1
! bin/st2 st2.c
:124gkk4n
122:  }
123:
124:}
125:
:123gd
:120g6n
120:    if (fp && fclose(fp) == EOF)
121:      perror("fclose"), exit(EXIT_FAILURE);
122:  }
123:}
124:
125:
:120gi
    }
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
:30n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
:20g20n
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  FILE *fp = fopen(argv[1], "r+");
31:  if (fp == NULL)
32:    perror("fopen"), exit(EXIT_FAILURE);
33:
34:  char buf[64] = "e\n";
35:  char *bufp = buf;
36:  goto begin;
37:
38:  while(!feof(stdin)) {
39:    if (*++bufp == '\n')
:30g4dwq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
:20n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
:120n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  char buf[64] = "e\n";
31:  char *bufp = buf;
32:  goto begin;
33:
34:  while(!feof(stdin)) {
35:    if (*++bufp == '\n')
36:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
37:
38:  begin:;
39:    int nread;
40:    unsigned cnt;
41:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
42:      nread = 0, cnt = 1;
43:    bufp += nread;
44:
45:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
46:      printf("?\n");
47:      continue;
48:    }
49:
50:    FILE *fp = NULL;
51:
52:    switch (*bufp) {
53:    case 'g':
54:      curr = cnt - 1;
55:      break;
56:    case 'j':
57:      curr += cnt;
58:      break;
59:    case 'k':
60:      curr -= cnt;
61:      break;
62:    case 'd':
63:      nlines -= cnt;
64:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
65:      memset(lines[nlines], 0, cnt * sizeof(*lines));
66:      break;
67:    case 'a':
68:      curr++;
69:    case 'i':
70:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
71:      nlines += cnt;
72:      break;
73:    case 'y':
74:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
75:      break;
76:    case 'x':
77:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
78:      nlines += cnt * ncut;
79:    case 'e':
80:      fp = fopen(argv[1], "r");
81:      break;
82:    case 'w':
83:      fp = fopen(argv[1], "w");
84:      break;
85:    case 'q':
86:      exit(EXIT_SUCCESS);
87:    }
88:
89:    for (unsigned n = 0; n < cnt; n++) {
90:      switch (*bufp) {
91:      case 'a':
92:      case 'i':
93:      case 'c':
94:        fgets(lines[curr + n], sizeof(*lines), stdin);
95:        break;
96:      case 'n':
97:        if (*lines[curr + n])
98:          printf("%u:", curr + n + 1);
99:      case 'p':
100:        fputs(lines[curr + n], stdout);
101:        break;
102:      case 'x':
103:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
104:        break;
105:      case 'e':
106:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
107:          cnt++;
108:        nlines = cnt;
109:        break;
110:      case 'w':
111:        cnt = nlines;
112:        fputs(lines[n], fp);
113:        break;
114:      }
115:
116:    }
117:    if (fp && fclose(fp) == EOF)
118:      perror("fclose"), exit(EXIT_FAILURE);
119:  }
120:}
:116ga

:wq
$ bin/st2 st2.c
:120g8n
120:  }
121:}
122:
123:
124:
125:
126:
127:
:122g1000n
122:
123:
124:
125:
126:
127:
128:
129:
130:
131:
132:
133:
134:
135:
136:
137:
138:
139:
140:
141:
142:
143:
144:
145:
146:
147:
148:
149:
150:
151:
152:
153:
154:
155:
156:
157:
158:
159:
160:
161:
162:
163:
164:
165:
166:
167:
168:
169:
170:
171:
172:
173:
174:
175:
176:
177:
178:
179:
180:
181:
182:
183:
184:
185:
186:
187:
188:
189:
190:
191:
192:
193:
194:
195:
196:
197:
198:
199:
200:
201:
202:
203:
204:
205:
206:
207:
208:
209:
210:
211:
212:
213:
214:
215:
216:
217:
218:
219:
220:
221:
222:
223:
224:
225:
226:
227:
228:
229:
230:
231:
232:
233:
234:
235:
236:
237:
238:
239:
240:
241:
242:
243:
244:
245:
246:
247:
248:
249:
250:
251:
252:
253:
254:
255:
256:
257:
258:
259:
260:
261:
262:
263:
264:
265:
266:
267:
268:
269:
270:
271:
272:
273:
274:
275:
276:
277:
278:
279:
280:
281:
282:
283:
284:
285:
286:
287:
288:
289:
290:
291:
292:
293:
294:
295:
296:
297:
298:
299:
300:
301:
302:
303:
304:
305:
306:
307:
308:
309:
310:
311:
312:
313:
314:
315:
316:
317:
318:
319:
320:
321:
322:
323:
324:
325:
326:
327:
328:
329:
330:
331:
332:
333:
334:
335:
336:
337:
338:
339:
340:
341:
342:
343:
344:
345:
346:
347:
348:
349:
350:
351:
352:
353:
354:
355:
356:
357:
358:
359:
360:
361:
362:
363:
364:
365:
366:
367:
368:
369:
370:
371:
372:
373:
374:
375:
376:
377:
378:
379:
380:
381:
382:
383:
384:
385:
386:
387:
388:
389:
390:
391:
392:
393:
394:
395:
396:
397:
398:
399:
400:
401:
402:
403:
404:
405:
406:
407:
408:
409:
410:
411:
412:
413:
414:
415:
416:
417:
418:
419:
420:
421:
422:
423:
424:
425:
426:
427:
428:
429:
430:
431:
432:
433:
434:
435:
436:
437:
438:
439:
440:
441:
442:
443:
444:
445:
446:
447:
448:
449:
450:
451:
452:
453:
454:
455:
456:
457:
458:
459:
460:
461:
462:
463:
464:
465:
466:
467:
468:
469:
470:
471:
472:
473:
474:
475:
476:
477:
478:
479:
480:
481:
482:
483:
484:
485:
486:
487:
488:
489:
490:
491:
492:
493:
494:
:360d1000n
122:
123:
124:
125:
126:
127:
128:
129:
130:
131:
132:
133:
134:
:13d
:110g15n
110:      case 'w':
111:        cnt = nlines;
112:        fputs(lines[n], fp);
113:        break;
114:      }
115:
116:    }
117:
118:    if (fp && fclose(fp) == EOF)
119:      perror("fclose"), exit(EXIT_FAILURE);
120:  }
121:}
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 Makefile
:10n
1:st1:
2:	mkdir -p bin
3:	gcc -O2 -Wall -Werror -pedantic -std=c99 st1.c -o bin/st1
4:
5:st2:
6:	mkdir -p bin
7:	gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
8:
9:clean:
10:	rm -rf bin
:5g4y4dgx10n
1:st2:
2:	mkdir -p bin
3:	gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
4:
5:st1:
6:	mkdir -p bin
7:	gcc -O2 -Wall -Werror -pedantic -std=c99 st1.c -o bin/st1
8:
9:clean:
10:	rm -rf bin
:wq
$ bin/st2 README.md
fish: Job 1, 'bin/st2 README.md' terminated by signal SIGSEGV (Address boundary error)
! bin/st2 st2.c
:70g20n
70:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
71:      nlines += cnt;
72:      break;
73:    case 'y':
74:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
75:      break;
76:    case 'x':
77:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
78:      nlines += cnt * ncut;
79:    case 'e':
80:      fp = fopen(argv[1], "r");
81:      break;
82:    case 'w':
83:      fp = fopen(argv[1], "w");
84:      break;
85:    case 'q':
86:      exit(EXIT_SUCCESS);
87:    }
88:
89:    for (unsigned n = 0; n < cnt; n++) {
:80g2a
      if (fp == NULL)
        perror("fopen"), exit(EXIT_FAILURE);
:2y86gx70g20n
70:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
71:      nlines += cnt;
72:      break;
73:    case 'y':
74:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
75:      break;
76:    case 'x':
77:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
78:      nlines += cnt * ncut;
79:    case 'e':
80:      fp = fopen(argv[1], "r");
81:      if (fp == NULL)
82:        perror("fopen"), exit(EXIT_FAILURE);
83:      break;
84:    case 'w':
85:      fp = fopen(argv[1], "w");
86:      if (fp == NULL)
87:        perror("fopen"), exit(EXIT_FAILURE);
88:      break;
89:    case 'q':
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 README.md
fopen: No such file or directory
! touch README.md
$ bin/st2 README.md
:3a
# #todo name

_#todo desc_
:3g4a

0. Write bare-bones line editor on paper. Man pages are fair play.
1. Use `cat` with shell redirection to write the listing from stage 0 to a file. Tweak and repeat until it builds and runs.
2. Use the bare-bones editor from stage 1 to bootstrap convenience fetures like error handling and copy/paste.
:5gpc
0. Write bare-bones line editor on paper. Man pages are fair play.
0. Write a bare-bones line editor on paper. Man pages are fair play.
:g10p
# #todo name


0. Write a bare-bones line editor on paper. Man pages are fair play.
1. Use `cat` with shell redirection to write the listing from stage 0 to a file. Tweak and repeat until it builds and runs.
2. Use the bare-bones editor from stage 1 to bootstrap convenience fetures such as error handling and copy-paste.
_#todo desc_
:7gyd3gxg10p
# #todo name

_#todo desc_

0. Write a bare-bones line editor on paper. Man pages are fair play.
1. Use `cat` with shell redirection to write the listing from stage 0 to a file. Tweak and repeat until it builds and runs.
2. Use the bare-bones editor from stage 1 to bootstrap convenience fetures such as error handling and copy-paste.
:7gpc
2. Use the bare-bones editor from stage 1 to bootstrap convenience fetures such as error handling and copy-paste.
2. Use the bare-bones editor from stage 1 to bootstrap convenience features such as error handling and copy-paste.
:wq
$ bin/st2 st2.c
:125n
1:#include <stdio.h>
2:#include <stdlib.h>
3:#include <string.h>
4:
5:// g - go to line number N
6:// j - move down N lines
7:// k - move up N lines
8:// a - append N new lines below
9:// i - insert N new lines above
10:// c - rewrite next N lines
11:// d - delete next N lines
12:// y - yank (copy) next N lines
13:// x - paste last yank N times
14:// n - print next N lines numbered
15:// p - print next N lines
16:// e - read file from disk
17:// w - write file to disk
18:// q - quit without confirmation
19:
20:unsigned curr = 0;
21:unsigned nlines = 0;
22:char lines[65536][256] = {0};
23:unsigned ncut = 0;
24:char cut[256][256] = {0};
25:
26:int main(int argc, char **argv) {
27:  if (argc != 2)
28:    fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
29:
30:  char buf[64] = "e\n";
31:  char *bufp = buf;
32:  goto begin;
33:
34:  while(!feof(stdin)) {
35:    if (*++bufp == '\n')
36:      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
37:
38:  begin:;
39:    int nread;
40:    unsigned cnt;
41:    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
42:      nread = 0, cnt = 1;
43:    bufp += nread;
44:
45:    if (!strchr("gjkaicdyxnpewq", *bufp)) {
46:      printf("?\n");
47:      continue;
48:    }
49:
50:    FILE *fp = NULL;
51:
52:    switch (*bufp) {
53:    case 'g':
54:      curr = cnt - 1;
55:      break;
56:    case 'j':
57:      curr += cnt;
58:      break;
59:    case 'k':
60:      curr -= cnt;
61:      break;
62:    case 'd':
63:      nlines -= cnt;
64:      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
65:      memset(lines[nlines], 0, cnt * sizeof(*lines));
66:      break;
67:    case 'a':
68:      curr++;
69:    case 'i':
70:      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
71:      nlines += cnt;
72:      break;
73:    case 'y':
74:      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
75:      break;
76:    case 'x':
77:      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
78:      nlines += cnt * ncut;
79:    case 'e':
80:      fp = fopen(argv[1], "r");
81:      if (fp == NULL)
82:        perror("fopen"), exit(EXIT_FAILURE);
83:      break;
84:    case 'w':
85:      fp = fopen(argv[1], "w");
86:      if (fp == NULL)
87:        perror("fopen"), exit(EXIT_FAILURE);
88:      break;
89:    case 'q':
90:      exit(EXIT_SUCCESS);
91:    }
92:
93:    for (unsigned n = 0; n < cnt; n++) {
94:      switch (*bufp) {
95:      case 'a':
96:      case 'i':
97:      case 'c':
98:        fgets(lines[curr + n], sizeof(*lines), stdin);
99:        break;
100:      case 'n':
101:        if (*lines[curr + n])
102:          printf("%u:", curr + n + 1);
103:      case 'p':
104:        fputs(lines[curr + n], stdout);
105:        break;
106:      case 'x':
107:        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
108:        break;
109:      case 'e':
110:        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
111:          cnt++;
112:        nlines = cnt;
113:        break;
114:      case 'w':
115:        cnt = nlines;
116:        fputs(lines[n], fp);
117:        break;
118:      }
119:
120:    }
121:
122:    if (fp && fclose(fp) == EOF)
123:      perror("fclose"), exit(EXIT_FAILURE);
124:  }
125:}
:102gpc
          printf("%u:", curr + n + 1);
          printf("%5u ", curr + n + 1);    
:i
          // 65536 is 5 chars long
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 st2.c
:128n
    1 #include <stdio.h>
    2 #include <stdlib.h>
    3 #include <string.h>
    4 
    5 // g - go to line number N
    6 // j - move down N lines
    7 // k - move up N lines
    8 // a - append N new lines below
    9 // i - insert N new lines above
   10 // c - rewrite next N lines
   11 // d - delete next N lines
   12 // y - yank (copy) next N lines
   13 // x - paste last yank N times
   14 // n - print next N lines numbered
   15 // p - print next N lines
   16 // e - read file from disk
   17 // w - write file to disk
   18 // q - quit without confirmation
   19 
   20 unsigned curr = 0;
   21 unsigned nlines = 0;
   22 char lines[65536][256] = {0};
   23 unsigned ncut = 0;
   24 char cut[256][256] = {0};
   25 
   26 int main(int argc, char **argv) {
   27   if (argc != 2)
   28     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
   29 
   30   char buf[64] = "e\n";
   31   char *bufp = buf;
   32   goto begin;
   33 
   34   while(!feof(stdin)) {
   35     if (*++bufp == '\n')
   36       putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
   37 
   38   begin:;
   39     int nread;
   40     unsigned cnt;
   41     if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
   42       nread = 0, cnt = 1;
   43     bufp += nread;
   44 
   45     if (!strchr("gjkaicdyxnpewq", *bufp)) {
   46       printf("?\n");
   47       continue;
   48     }
   49 
   50     FILE *fp = NULL;
   51 
   52     switch (*bufp) {
   53     case 'g':
   54       curr = cnt - 1;
   55       break;
   56     case 'j':
   57       curr += cnt;
   58       break;
   59     case 'k':
   60       curr -= cnt;
   61       break;
   62     case 'd':
   63       nlines -= cnt;
   64       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
   65       memset(lines[nlines], 0, cnt * sizeof(*lines));
   66       break;
   67     case 'a':
   68       curr++;
   69     case 'i':
   70       memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
   71       nlines += cnt;
   72       break;
   73     case 'y':
   74       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
   75       break;
   76     case 'x':
   77       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
   78       nlines += cnt * ncut;
   79     case 'e':
   80       fp = fopen(argv[1], "r");
   81       if (fp == NULL)
   82         perror("fopen"), exit(EXIT_FAILURE);
   83       break;
   84     case 'w':
   85       fp = fopen(argv[1], "w");
   86       if (fp == NULL)
   87         perror("fopen"), exit(EXIT_FAILURE);
   88       break;
   89     case 'q':
   90       exit(EXIT_SUCCESS);
   91     }
   92 
   93     for (unsigned n = 0; n < cnt; n++) {
   94       switch (*bufp) {
   95       case 'a':
   96       case 'i':
   97       case 'c':
   98         fgets(lines[curr + n], sizeof(*lines), stdin);
   99         break;
  100       case 'n':
  101         if (*lines[curr + n])
  102           // 65536 is 5 chars long
  103           printf("%5u ", curr + n + 1);
  104       case 'p':
  105         fputs(lines[curr + n], stdout);
  106         break;
  107       case 'x':
  108         memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
  109         break;
  110       case 'e':
  111         if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
  112           cnt++;
  113         nlines = cnt;
  114         break;
  115       case 'w':
  116         cnt = nlines;
  117         fputs(lines[n], fp);
  118         break;
  119       }
  120 
  121     }
  122 
  123     if (fp && fclose(fp) == EOF)
  124       perror("fclose"), exit(EXIT_FAILURE);
  125   }
  126 }
:102g2pdc
          // 65536 is 5 chars long
          printf("%5u ", curr + n + 1);
          printf("%5u ", curr + n + 1); // 65536 is 5 chars long
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st2 README.md
:3gpc
_#todo desc_
_Minimal text editor bootstrapped from `cat`_
:2a

The bootstrapping process consists of several stages:
:20n
    3 _Minimal text editor bootstrapped from `cat`_
    4 
    5 The bootstrapping process consists of several stages:
    6 
    7 0. Write a bare-bones line editor on paper. Man pages are fair play.
    8 1. Use `cat` with shell redirection to write the listing from stage 0 to a file. Tweak and repeat until it builds and runs.
    9 2. Use the bare-bones editor from stage 1 to bootstrap convenience features such as error handling and copy-paste.
:9gpc
2. Use the bare-bones editor from stage 1 to bootstrap convenience features such as error handling and copy-paste.
2. Use the bare-bones line editor from stage 1 to bootstrap convenience features such as error handling and copy-paste.
:wq
$ bin/st2 st2.c
:111gpdc
          cnt++;
          nlines = ++cnt;
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ cp st2.c st3.c
$ bin/st2 Makefile 
:9n
    1 st2:
    2 	mkdir -p bin
    3 	gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
    4 
    5 st1:
    6 	mkdir -p bin
    7 	gcc -O2 -Wall -Werror -pedantic -std=c99 st1.c -o bin/st1
    8 
    9 clean:
:4i 
st3:
	mkdir -p bin
	gcc -O2 -Wall -Werror -pedantic -std=c99 st3.c -o bin/st3

:wq
$ bin/st2 st3.c
:18g6a

char *hi_default = "\033[m";
char *hi_keyword = "\033[1m";
char *hi_comment = "\033[2;3m";
char *hi_operator = "\033[2m";
char *hi_literal = "\033[3m";
:8n
   19 
   20 char *hi_default = "\033[m";
   21 char *hi_keyword = "\033[1m";
   22 char *hi_comment = "\033[2;3m";
   23 char *hi_operator = "\033[2m";
   24 char *hi_literal = "\033[3m";
   25 
   26 unsigned curr = 0;
:24g6a

char *hi_c(char **src) {
  static char *kws[] = {
    "auto", "break", "case", "char", "const", "continue",
    "default", "do", "double", "else", "enum", "extern",
    "float", "for", "goto", "if", "inline", "int",
:2a
     

:24g8n
   24 char *hi_literal = "\033[3m";
   25 
   26 
   27 
   28 char *hi_c(char **src) {
   29   static char *kws[] = {
   30     "auto", "break", "case", "char", "const", "continue",
   31     "default", "do", "double", "else", "enum", "extern",
:25gdd8n
   25 
   26 char *hi_c(char **src) {
   27   static char *kws[] = {
   28     "auto", "break", "case", "char", "const", "continue",
   29     "default", "do", "double", "else", "enum", "extern",
   30     "float", "for", "goto", "if", "inline", "int",
   31 
   32 unsigned curr = 0;
:30g3a
    "long", "register", "restrict", "return", "short", "signed",
    "sizeof", "static", "struct", "switch", "true", "typedef", 
    "union", "unsigned", "void", "volatile", "while", "_Bool",
:3n
   31     "long", "register", "restrict", "return", "short", "signed",
   32     "sizeof", "static", "struct", "switch", "true", "typedef",
   33     "union", "unsigned", "void", "volatile", "while", "_Bool",
:33g2a
    "_Complex", "_Imaginary",
  };
:34gpc
    "_Complex", "_Imaginary",
    "_Complex", "_Imaginary", NULL,
:35g4a
  static char *pps = {
    "if", "elif", "else", "endif", "ifdef", "ifndef",
    "define", "undef", "include", "line", "error", "pragma",
    NULL,    
:39gpa
    NULL,
  };
:40g4a
  static char *ops = {
    "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=",            
    "^=", "<<=", ">>=", "++", "--", "+", "-", "*",
    "/", "%", "~", "&", "|", "^", "<<", ">>",
:44g3a
    "!", "&&", "||", "==", "!=", "<", ">", "<=",
    ">=", "[", "]", "->", ".", "(", ")", ",",
    "?", ":", "sizeof", NULL,
:47g2a
  };
}
:w
:18g20n
   18 // q - quit without confirmation
   19 
   20 char *hi_default = "\033[m";
   21 char *hi_keyword = "\033[1m";
   22 char *hi_comment = "\033[2;3m";
   23 char *hi_operator = "\033[2m";
   24 char *hi_literal = "\033[3m";
   25 
   26 char *hi_c(char **src) {
   27   static char *kws[] = {
   28     "auto", "break", "case", "char", "const", "continue",
   29     "default", "do", "double", "else", "enum", "extern",
   30     "float", "for", "goto", "if", "inline", "int",
   31     "long", "register", "restrict", "return", "short", "signed",
   32     "sizeof", "static", "struct", "switch", "true", "typedef",
   33     "union", "unsigned", "void", "volatile", "while", "_Bool",
   34     "_Complex", "_Imaginary", NULL,
   35   };
   36   static char *pps = {
   37     "if", "elif", "else", "endif", "ifdef", "ifndef",
:40n
   18 // q - quit without confirmation
   19 
   20 char *hi_default = "\033[m";
   21 char *hi_keyword = "\033[1m";
   22 char *hi_comment = "\033[2;3m";
   23 char *hi_operator = "\033[2m";
   24 char *hi_literal = "\033[3m";
   25 
   26 char *hi_c(char **src) {
   27   static char *kws[] = {
   28     "auto", "break", "case", "char", "const", "continue",
   29     "default", "do", "double", "else", "enum", "extern",
   30     "float", "for", "goto", "if", "inline", "int",
   31     "long", "register", "restrict", "return", "short", "signed",
   32     "sizeof", "static", "struct", "switch", "true", "typedef",
   33     "union", "unsigned", "void", "volatile", "while", "_Bool",
   34     "_Complex", "_Imaginary", NULL,
   35   };
   36   static char *pps = {
   37     "if", "elif", "else", "endif", "ifdef", "ifndef",
   38     "define", "undef", "include", "line", "error", "pragma",
   39     NULL,
   40   };
   41   static char *ops = {
   42     "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=",
   43     "^=", "<<=", ">>=", "++", "--", "+", "-", "*",
   44     "/", "%", "~", "&", "|", "^", "<<", ">>",
   45     "!", "&&", "||", "==", "!=", "<", ">", "<=",
   46     ">=", "[", "]", "->", ".", "(", ")", ",",
   47     "?", ":", "sizeof", NULL,
   48   };
   49 }
   50 
   51 unsigned curr = 0;
   52 unsigned nlines = 0;
   53 char lines[65536][256] = {0};
   54 unsigned ncut = 0;
   55 char cut[256][256] = {0};
   56 
   57 int main(int argc, char **argv) {
:48g2a
  char *ws = " \t\n\v\f";
  char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
:2y2d26gjx18g40n
   18 // q - quit without confirmation
   19 
   20 char *hi_default = "\033[m";
   21 char *hi_keyword = "\033[1m";
   22 char *hi_comment = "\033[2;3m";
   23 char *hi_operator = "\033[2m";
   24 char *hi_literal = "\033[3m";
   25 
   26 char *hi_c(char **src) {
   27   char *ws = " \t\n\v\f";
   28   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
   29   static char *kws[] = {
   30     "auto", "break", "case", "char", "const", "continue",
   31     "default", "do", "double", "else", "enum", "extern",
   32     "float", "for", "goto", "if", "inline", "int",
   33     "long", "register", "restrict", "return", "short", "signed",
   34     "sizeof", "static", "struct", "switch", "true", "typedef",
   35     "union", "unsigned", "void", "volatile", "while", "_Bool",
   36     "_Complex", "_Imaginary", NULL,
   37   };
   38   static char *pps = {
   39     "if", "elif", "else", "endif", "ifdef", "ifndef",
   40     "define", "undef", "include", "line", "error", "pragma",
   41     NULL,
   42   };
   43   static char *ops = {
   44     "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=",
   45     "^=", "<<=", ">>=", "++", "--", "+", "-", "*",
   46     "/", "%", "~", "&", "|", "^", "<<", ">>",
   47     "!", "&&", "||", "==", "!=", "<", ">", "<=",
   48     ">=", "[", "]", "->", ".", "(", ")", ",",
   49     "?", ":", "sizeof", NULL,
   50   };
   51 }
   52 
   53 unsigned curr = 0;
   54 unsigned nlines = 0;
   55 char lines[65536][256] = {0};
   56 unsigned ncut = 0;
   57 char cut[256][256] = {0};
:38gpc43gpc
  static char *pps = {
  static char *pps[] = {
  static char *ops = {
  static char *ops[] = {
:50g5a

  if (strchr(ws, **src))
    return ++*src, hi_default;

  return ++*src, hi_default;
:53g4a

  for (char *op = *ops; *op; op++)
    if (strncmp(*src, op, strlen(op) == 0)
      return *src += strlen(op), hi_operator;
:56gpc
    if (strncmp(*src, op, strlen(op) == 0)
    if (strncmp(*src, op, strlen(op)) == 0)
:w
:60g20n
   60 }
   61 
   62 unsigned curr = 0;
   63 unsigned nlines = 0;
   64 char lines[65536][256] = {0};
   65 unsigned ncut = 0;
   66 char cut[256][256] = {0};
   67 
   68 int main(int argc, char **argv) {
   69   if (argc != 2)
   70     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
   71 
   72   char buf[64] = "e\n";
   73   char *bufp = buf;
   74   goto begin;
   75 
   76   while(!feof(stdin)) {
   77     if (*++bufp == '\n')
   78       putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
   79 
:78gpc
      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
      fputs("\033[m:", stdout), fgets(buf, sizeof(buf), stdin);
:78gpc
      fputs("\033[m:", stdout), fgets(buf, sizeof(buf), stdin);
      fputs("\033[m:", stdout), bufp = fgets(buf, sizeof(buf), stdin);
:150g20n
  150         break;
  151       case 'e':
  152         if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
  153           nlines = ++cnt;
  154         break;
  155       case 'w':
  156         cnt = nlines;
  157         fputs(lines[n], fp);
  158         break;
  159       }
  160 
  161     }
  162 
  163     if (fp && fclose(fp) == EOF)
  164       perror("fclose"), exit(EXIT_FAILURE);
  165   }
  166 }
:120g20n
  120       nlines += cnt * ncut;
  121     case 'e':
  122       fp = fopen(argv[1], "r");
  123       if (fp == NULL)
  124         perror("fopen"), exit(EXIT_FAILURE);
  125       break;
  126     case 'w':
  127       fp = fopen(argv[1], "w");
  128       if (fp == NULL)
  129         perror("fopen"), exit(EXIT_FAILURE);
  130       break;
  131     case 'q':
  132       exit(EXIT_SUCCESS);
  133     }
  134 
  135     for (unsigned n = 0; n < cnt; n++) {
  136       switch (*bufp) {
  137       case 'a':
  138       case 'i':
  139       case 'c':
:140g10n
  140         fgets(lines[curr + n], sizeof(*lines), stdin);
  141         break;
  142       case 'n':
  143         if (*lines[curr + n])
  144           printf("%5u ", curr + n + 1); // 65536 is 5 chars long
  145       case 'p':
  146         fputs(lines[curr + n], stdout);
  147         break;
  148       case 'x':
  149         memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
:144gpc
          printf("%5u ", curr + n + 1); // 65536 is 5 chars long
          printf("\033[2;3m%5u ", curr + n + 1); // 65536 is 5 chars long
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: error: unused variable ‘pps’ [-Werror=unused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c:29:16: error: unused variable ‘kws’ [-Werror=unused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:28:9: error: unused variable ‘sep’ [-Werror=unused-variable]
   28 |   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
      |         ^~~
st3.c: At top level:
st3.c:29:16: error: ‘kws’ defined but not used [-Werror=unused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:38:16: error: ‘pps’ defined but not used [-Werror=unused-variable]
   38 |   static char *pps[] = {
      |                ^~~
cc1: all warnings being treated as errors
make: *** [Makefile:3: st3] Error 1
! bin/st2 Makefile 
:5n
    1 st3:
    2 	mkdir -p bin
    3 	gcc -O2 -Wall -Werror -pedantic -std=c99 st3.c -o bin/st3
    4 
    5 st2:
:3gpc
	gcc -O2 -Wall -Werror -pedantic -std=c99 st3.c -o bin/st3
	gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c:29:16: warning: unused variable ‘kws’ [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:28:9: warning: unused variable ‘sep’ [-Wunused-variable]
   28 |   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
      |         ^~~
st3.c: At top level:
st3.c:29:16: warning: ‘kws’ defined but not used [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
$ bin/st3 st3.c
:8n
    1 #include <stdio.h>
    2 #include <stdlib.h>
    3 #include <string.h>
    4 
    5 // g - go to line number N
    6 // j - move down N lines
    7 // k - move up N lines
    8 // a - append N new lines below
:q
$ bin/st3 st3.c
:8n
    1 #include <stdio.h>
    2 #include <stdlib.h>
    3 #include <string.h>
    4 
    5 // g - go to line number N
    6 // j - move down N lines
    7 // k - move up N lines
    8 // a - append N new lines below
:q
$ bin/st2 st3.c
:146gpc5a
        fputs(lines[curr + n], stdout);
        char *start, *end = lines[curr + n];
        while (*end) {
          fputs(hi_c(&end), stdout);
          printf("%.*s", end - start, start);
        }

:147gpc  
        while (*end) {
        for (char *start = end; *start; start = end) {
:146gc
        char *end = lines[curr + n];
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c:29:16: warning: unused variable ‘kws’ [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:28:9: warning: unused variable ‘sep’ [-Wunused-variable]
   28 |   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
      |         ^~~
st3.c: In function ‘main’:
st3.c:146:9: warning: a label can only be part of a statement and a declaration is not a statement [-Wpedantic]
  146 |         char *end = lines[curr + n];
      |         ^~~~
st3.c:149:21: warning: field precision specifier ‘.*’ expects argument of type ‘int’, but argument 2 has type ‘long int’ [-Wformat=]
  149 |           printf("%.*s", end - start, start);
      |                   ~~^~   ~~~~~~~~~~~
      |                     |        |
      |                     int      long int
st3.c: At top level:
st3.c:29:16: warning: ‘kws’ defined but not used [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
$ bin/st2 st3.c
:149gpc
          printf("%.*s", end - start, start);
          printf("%.*s", (int)(end - start), start);
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c:29:16: warning: unused variable ‘kws’ [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:28:9: warning: unused variable ‘sep’ [-Wunused-variable]
   28 |   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
      |         ^~~
st3.c: In function ‘main’:
st3.c:146:9: warning: a label can only be part of a statement and a declaration is not a statement [-Wpedantic]
  146 |         char *end = lines[curr + n];
      |         ^~~~
st3.c: At top level:
st3.c:29:16: warning: ‘kws’ defined but not used [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
$ bin/st2 st3.c
:145gpc
      case 'p':
      case 'p': {
:151g2p2c

        break;
      } break;
  
:152gpd

:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c:29:16: warning: unused variable ‘kws’ [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:28:9: warning: unused variable ‘sep’ [-Wunused-variable]
   28 |   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
      |         ^~~
st3.c: At top level:
st3.c:29:16: warning: ‘kws’ defined but not used [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
$ bin/st3 st3.c
:55gpc
  for (char *op = *ops; *op; op++)
  for (char **op = ops; *op; op++)
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:56:34: warning: passing argument 1 of ‘strlen’ from incompatible pointer type [-Wincompatible-pointer-types]
   56 |     if (strncmp(*src, op, strlen(op)) == 0)
      |                                  ^~
      |                                  |
      |                                  char **
In file included from st3.c:3:
/nix/store/lw5b7x8wndk7sdis78r2f8fy12ldmpwc-glibc-2.37-45-dev/include/string.h:407:35: note: expected ‘const char *’ but argument is of type ‘char **’
  407 | extern size_t strlen (const char *__s)
      |                       ~~~~~~~~~~~~^~~
st3.c:56:23: warning: passing argument 2 of ‘strncmp’ from incompatible pointer type [-Wincompatible-pointer-types]
   56 |     if (strncmp(*src, op, strlen(op)) == 0)
      |                       ^~
      |                       |
      |                       char **
/nix/store/lw5b7x8wndk7sdis78r2f8fy12ldmpwc-glibc-2.37-45-dev/include/string.h:159:51: note: expected ‘const char *’ but argument is of type ‘char **’
  159 | extern int strncmp (const char *__s1, const char *__s2, size_t __n)
      |                                       ~~~~~~~~~~~~^~~~
st3.c:57:29: warning: passing argument 1 of ‘strlen’ from incompatible pointer type [-Wincompatible-pointer-types]
   57 |       return *src += strlen(op), hi_operator;
      |                             ^~
      |                             |
      |                             char **
/nix/store/lw5b7x8wndk7sdis78r2f8fy12ldmpwc-glibc-2.37-45-dev/include/string.h:407:35: note: expected ‘const char *’ but argument is of type ‘char **’
  407 | extern size_t strlen (const char *__s)
      |                       ~~~~~~~~~~~~^~~
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c:29:16: warning: unused variable ‘kws’ [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:28:9: warning: unused variable ‘sep’ [-Wunused-variable]
   28 |   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
      |         ^~~
st3.c: At top level:
st3.c:29:16: warning: ‘kws’ defined but not used [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
$ bin/st3 st3.c
:56gpc
    if (strncmp(*src, op, strlen(op)) == 0)
    if (strncmp(*src, *op, strlen(*op)) == 0)
:57gpc
      return *src += strlen(op), hi_operator;
      return *src += strlen(*op), hi_operator;
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c:29:16: warning: unused variable ‘kws’ [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:28:9: warning: unused variable ‘sep’ [-Wunused-variable]
   28 |   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
      |         ^~~
st3.c: At top level:
st3.c:29:16: warning: ‘kws’ defined but not used [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
$ bin/st3 st3.c
:29g29n
   29   static char *kws[] = {
   30     "auto", "break", "case", "char", "const", "continue",
   31     "default", "do", "double", "else", "enum", "extern",
   32     "float", "for", "goto", "if", "inline", "int",
   33     "long", "register", "restrict", "return", "short", "signed",
   34     "sizeof", "static", "struct", "switch", "true", "typedef",
   35     "union", "unsigned", "void", "volatile", "while", "_Bool",
   36     "_Complex", "_Imaginary", NULL,
   37   };
   38   static char *pps[] = {
   39     "if", "elif", "else", "endif", "ifdef", "ifndef",
   40     "define", "undef", "include", "line", "error", "pragma",
   41     NULL,
   42   };
   43   static char *ops[] = {
   44     "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=",
   45     "^=", "<<=", ">>=", "++", "--", "+", "-", "*",
   46     "/", "%", "~", "&", "|", "^", "<<", ">>",
   47     "!", "&&", "||", "==", "!=", "<", ">", "<=",
   48     ">=", "[", "]", "->", ".", "(", ")", ",",
   49     "?", ":", "sizeof", NULL,
   50   };
   51 
   52   if (strchr(ws, **src))
   53     return ++*src, hi_default;
   54 
   55   for (char **op = ops; *op; op++)
   56     if (strncmp(*src, *op, strlen(*op)) == 0)
   57       return *src += strlen(*op), hi_operator;
:57g5a

  for (char **kw = kws; *kw; kw++)
    if (strncmp(*src, *kw, strlen(*kw)) == 0)
      if (strchr(sep, (*src)[strlen(*kw)]))
        return *src += strlen(*kw), hi_keyword;
:25g8n
   25 
   26 char *hi_c(char **src) {
   27   char *ws = " \t\n\v\f";
   28   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
   29   static char *kws[] = {
   30     "auto", "break", "case", "char", "const", "continue",
   31     "default", "do", "double", "else", "enum", "extern",
   32     "float", "for", "goto", "if", "inline", "int",
:28gpc
  char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~";
  char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~ \t\n\v\f";
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c: At top level:
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
$ bin/st3 st3.c
:20g20n
   20 char *hi_default = "\033[m";
   21 char *hi_keyword = "\033[1m";
   22 char *hi_comment = "\033[2;3m";
   23 char *hi_operator = "\033[2m";
   24 char *hi_literal = "\033[3m";
   25 
   26 char *hi_c(char **src) {
   27   char *ws = " \t\n\v\f";
   28   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~ \t\n\v\f";
   29   static char *kws[] = {
   30     "auto", "break", "case", "char", "const", "continue",
   31     "default", "do", "double", "else", "enum", "extern",
   32     "float", "for", "goto", "if", "inline", "int",
   33     "long", "register", "restrict", "return", "short", "signed",
   34     "sizeof", "static", "struct", "switch", "true", "typedef",
   35     "union", "unsigned", "void", "volatile", "while", "_Bool",
   36     "_Complex", "_Imaginary", NULL,
   37   };
   38   static char *pps[] = {
   39     "if", "elif", "else", "endif", "ifdef", "ifndef",
:20g5p5c      
char *hi_default = "\033[m";
char *hi_keyword = "\033[1m";
char *hi_comment = "\033[2;3m";
char *hi_operator = "\033[2m";
char *hi_literal = "\033[3m";
char *hi_default = "\033[m";
char *hi_keyword = "\033[;1m";
char *hi_comment = "\033[;2;3m";
char *hi_operator = "\033[;2m";
char *hi_literal = "\033[;3m";
:g8n
    1 #include <stdio.h>
    2 #include <stdlib.h>
    3 #include <string.h>
    4 
    5 // g - go to line number N
    6 // j - move down N lines
    7 // k - move up N lines
    8 // a - append N new lines below
:3ga
#include <ctype.h>
:26ga
int isident(int c) { return c == '_' || isalnum(c); }
:30g30n
   30   char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~ \t\n\v\f";
   31   static char *kws[] = {
   32     "auto", "break", "case", "char", "const", "continue",
   33     "default", "do", "double", "else", "enum", "extern",
   34     "float", "for", "goto", "if", "inline", "int",
   35     "long", "register", "restrict", "return", "short", "signed",
   36     "sizeof", "static", "struct", "switch", "true", "typedef",
   37     "union", "unsigned", "void", "volatile", "while", "_Bool",
   38     "_Complex", "_Imaginary", NULL,
   39   };
   40   static char *pps[] = {
   41     "if", "elif", "else", "endif", "ifdef", "ifndef",
   42     "define", "undef", "include", "line", "error", "pragma",
   43     NULL,
   44   };
   45   static char *ops[] = {
   46     "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=",
   47     "^=", "<<=", ">>=", "++", "--", "+", "-", "*",
   48     "/", "%", "~", "&", "|", "^", "<<", ">>",
   49     "!", "&&", "||", "==", "!=", "<", ">", "<=",
   50     ">=", "[", "]", "->", ".", "(", ")", ",",
   51     "?", ":", "sizeof", NULL,
   52   };
   53 
   54   if (strchr(ws, **src))
   55     return ++*src, hi_default;
   56 
   57   for (char **op = ops; *op; op++)
   58     if (strncmp(*src, *op, strlen(*op)) == 0)
   59       return *src += strlen(*op), hi_operator;
:50g30n
   50     ">=", "[", "]", "->", ".", "(", ")", ",",
   51     "?", ":", "sizeof", NULL,
   52   };
   53 
   54   if (strchr(ws, **src))
   55     return ++*src, hi_default;
   56 
   57   for (char **op = ops; *op; op++)
   58     if (strncmp(*src, *op, strlen(*op)) == 0)
   59       return *src += strlen(*op), hi_operator;
   60 
   61   for (char **kw = kws; *kw; kw++)
   62     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   63       if (strchr(sep, (*src)[strlen(*kw)]))
   64         return *src += strlen(*kw), hi_keyword;
   65 
   66   return ++*src, hi_default;
   67 }
   68 
   69 unsigned curr = 0;
   70 unsigned nlines = 0;
   71 char lines[65536][256] = {0};
   72 unsigned ncut = 0;
   73 char cut[256][256] = {0};
   74 
   75 int main(int argc, char **argv) {
   76   if (argc != 2)
   77     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
   78 
   79   char buf[64] = "e\n";
:63gpc
      if (strchr(sep, (*src)[strlen(*kw)]))
      if (!isident((*str)[strlen(*kw)]))
:64g5a

  if (isident(**src)) {
    while (isident(*++*src)); 
    return hi_default;
  }
:29g2p
  char *ws = " \t\n\v\f";
  char *sep = "!\"#%&'()*+,-./:;<=>?[\\]^{|}~ \t\n\v\f";
:2d
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:52:14: error: ‘ws’ undeclared (first use in this function); did you mean ‘kws’?
   52 |   if (strchr(ws, **src))
      |              ^~
      |              kws
st3.c:52:14: note: each undeclared identifier is reported only once for each function it appears in
st3.c:61:22: error: ‘str’ undeclared (first use in this function)
   61 |       if (!isident((*str)[strlen(*kw)]))
      |                      ^~~
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c: At top level:
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
make: *** [Makefile:3: st3] Error 1
! bin/st3 st3.c
:52gpc
  if (strchr(ws, **src))
  if (isspace(**src))
:61gpc
      if (!isident((*str)[strlen(*kw)]))
      if (!isident((*src)[strlen(*kw)]))
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c: At top level:
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
$ bin/st3 st3.c
:50g20n
   50   };
   51 
   52   if (isspace(**src))
   53     return ++*src, hi_default;
   54 
   55   for (char **op = ops; *op; op++)
   56     if (strncmp(*src, *op, strlen(*op)) == 0)
   57       return *src += strlen(*op), hi_operator;
   58 
   59   for (char **kw = kws; *kw; kw++)
   60     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   61       if (!isident((*src)[strlen(*kw)]))
   62         return *src += strlen(*kw), hi_keyword;
   63 
   64   if (isident(**src)) {
   65     while (isident(*++*src));
   66     return hi_default;
   67   }
   68 
   69   return ++*src, hi_default;
:67g6a

  if (**src == '"') {
    while (*++*src != '"')
      if (**src == '\\')
        ++*src;
    return src++, hi_literal;
:70gca
  char quote = **src;
  while (*++*src != quote)
:69gpc
  if (**src == '"') {
  if (**src == '"' || **src == '\'') {
:65g8n
   65     while (isident(*++*src));
   66     return hi_default;
   67   }
   68 
   69   if (**src == '"' || **src == '\'') {
   70   char quote = **src;
   71   while (*++*src != quote)
   72       if (**src == '\\')
:69g8n
   69   if (**src == '"' || **src == '\'') {
   70   char quote = **src;
   71   while (*++*src != quote)
   72       if (**src == '\\')
   73         ++*src;
   74     return src++, hi_literal;
   75 
   76   return ++*src, hi_default;
:74ga
  }
:70g2p2c
  char quote = **src;
  while (*++*src != quote)
    char quote = **src;
    while (*++*src != quote)
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c: At top level:
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
$ bin/st3 st3.c
:30n
    1 #include <stdio.h>
    2 #include <stdlib.h>
    3 #include <string.h>
    4 #include <ctype.h>
    5 
    6 // g - go to line number N
    7 // j - move down N lines
    8 // k - move up N lines
    9 // a - append N new lines below
   10 // i - insert N new lines above
   11 // c - rewrite next N lines
   12 // d - delete next N lines
   13 // y - yank (copy) next N lines
   14 // x - paste last yank N times
   15 // n - print next N lines numbered
   16 // p - print next N lines
   17 // e - read file from disk
   18 // w - write file to disk
   19 // q - quit without confirmation
   20 
   21 char *hi_default = "\033[m";
"\033[;1m";
"\033[;2;3m";
"\033[;2m";
"\033[;3m";
"auto", "break", "case", "char", "const", "continue",
"default", "do", "double", "else", "enum", "extern",
"float", "for", "goto", "if", "inline", "int",
"long", "register", "restrict", "return", "short", "signed",
"sizeof", "static", "struct", "switch", "true", "typedef",
"union", "unsigned", "void", "volatile", "while", "_Bool",
"_Complex", "_Imaginary", NULL,
"if", "elif", "else", "endif", "ifdef", "ifndef",
"define", "undef", "include", "line", "error", "pragma",
"=", "+=", "-=", "*=", "/=", "%=", "&=", "|=",
"^=", "<<=", ">>=", "++", "--", "+", "-", "*",
"/", "%", "~", "&", "|", "^", "<<", ">>",
"!", "&&", "||", "==", "!=", "<", ">", "<=",
">=", "[", "]", "->", ".", "(", ")", ",",
"?", ":", "sizeof", NULL,
"' || **src == '\'') {
"Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
"e\n";
"\033[m:", stdout), bufp = fgets(buf, sizeof(buf), stdin);
"%u%n", &cnt, &nread) != 1)
"gjkaicdyxnpewq", *bufp)) {
"?\n");
"r");
"fopen"), exit(EXIT_FAILURE);
"w");
"fopen"), exit(EXIT_FAILURE);
"\033[2;3m%5u ", curr + n + 1); // 65536 is 5 chars long
"%.*s", (int)(end - start), start);
fish: Job 1, 'bin/st3 st3.c' terminated by signal SIGSEGV (Address boundary error)
! bin/st2 st3.c
:74gpc
    return src++, hi_literal;
    return ++*src, hi_literal;
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:38:16: warning: unused variable ‘pps’ [-Wunused-variable]
   38 |   static char *pps[] = {
      |                ^~~
st3.c: At top level:
st3.c:38:16: warning: ‘pps’ defined but not used [-Wunused-variable]
$ bin/st3 st3.c
:30n
    1 #include <stdio.h>
    2 #include <stdlib.h>
    3 #include <string.h>
    4 #include <ctype.h>
    5 
    6 // g - go to line number N
    7 // j - move down N lines
    8 // k - move up N lines
    9 // a - append N new lines below
   10 // i - insert N new lines above
   11 // c - rewrite next N lines
   12 // d - delete next N lines
   13 // y - yank (copy) next N lines
   14 // x - paste last yank N times
   15 // n - print next N lines numbered
   16 // p - print next N lines
   17 // e - read file from disk
   18 // w - write file to disk
   19 // q - quit without confirmation
   20 
   21 char *hi_default = "\033[m";
   22 char *hi_keyword = "\033[;1m";
   23 char *hi_comment = "\033[;2;3m";
   24 char *hi_operator = "\033[;2m";
   25 char *hi_literal = "\033[;3m";
   26 
   27 int isident(int c) { return c == '_' || isalnum(c); }
   28 char *hi_c(char **src) {
   29   static char *kws[] = {
   30     "auto", "break", "case", "char", "const", "continue",
:60g30n
   60     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   61       if (!isident((*src)[strlen(*kw)]))
   62         return *src += strlen(*kw), hi_keyword;
   63 
   64   if (isident(**src)) {
   65     while (isident(*++*src));
   66     return hi_default;
   67   }
   68 
   69   if (**src == '"' || **src == '\'') {
   70     char quote = **src;
   71     while (*++*src != quote)
   72       if (**src == '\\')
   73         ++*src;
   74     return ++*src, hi_literal;
   75   }
   76 
   77   return ++*src, hi_default;
   78 }
   79 
   80 unsigned curr = 0;
   81 unsigned nlines = 0;
   82 char lines[65536][256] = {0};
   83 unsigned ncut = 0;
   84 char cut[256][256] = {0};
   85 
   86 int main(int argc, char **argv) {
   87   if (argc != 2)
   88     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
   89 
:75g6a

  if (**src == '#') {
    while (isspace(*++*src));
    for (char **pp = pps; *pp; pp++)
      if (strncmp(*src, *pp, strlen(*pp)) == 0)
        if (!isident((*src)[strlen(*pp)]))
:81gp3a
        if (!isident((*src)[strlen(*pp)]))
          return *src += strlen(*pp), hi_keyword;
    return hi_default;
  }
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
$ bin/st3 st3.c
:50g30n
   50   };
   51 
   52   if (isspace(**src))
   53     return ++*src, hi_default;
   54 
   55   for (char **op = ops; *op; op++)
   56     if (strncmp(*src, *op, strlen(*op)) == 0)
   57       return *src += strlen(*op), hi_operator;
   58 
   59   for (char **kw = kws; *kw; kw++)
   60     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   61       if (!isident((*src)[strlen(*kw)]))
   62         return *src += strlen(*kw), hi_keyword;
   63 
   64   if (isident(**src)) {
   65     while (isident(*++*src));
   66     return hi_default;
   67   }
   68 
   69   if (**src == '"' || **src == '\'') {
   70     char quote = **src;
   71     while (*++*src != quote)
   72       if (**src == '\\')
   73         ++*src;
   74     return ++*src, hi_literal;
   75   }
   76 
   77   if (**src == '#') {
   78     while (isspace(*++*src));
   79     for (char **pp = pps; *pp; pp++)
:55g5y5d64gx50g30n
   50   };
   51 
   52   if (isspace(**src))
   53     return ++*src, hi_default;
   54 
   55     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   56       if (!isident((*src)[strlen(*kw)]))
   57         return *src += strlen(*kw), hi_keyword;
   58 
   59   if (isident(**src)) {
   60     while (isident(*++*src));
   61     return hi_default;
   62   }
   63 
   64   for (char **op = ops; *op; op++)
   65     if (strncmp(*src, *op, strlen(*op)) == 0)
   66       return *src += strlen(*op), hi_operator;
   67 
   68   for (char **kw = kws; *kw; kw++)
   69   if (**src == '"' || **src == '\'') {
   70     char quote = **src;
   71     while (*++*src != quote)
   72       if (**src == '\\')
   73         ++*src;
   74     return ++*src, hi_literal;
   75   }
   76 
   77   if (**src == '#') {
   78     while (isspace(*++*src));
   79     for (char **pp = pps; *pp; pp++)
:68gd77g8n
   77     while (isspace(*++*src));
   78     for (char **pp = pps; *pp; pp++)
   79       if (strncmp(*src, *pp, strlen(*pp)) == 0)
   80         if (!isident((*src)[strlen(*pp)]))
   81           return *src += strlen(*pp), hi_keyword;
   82     return hi_default;
   83   }
   84 
:83g5a

  if (strncmp(*src, "//", 2)) {
    while (**src && *++*src != '\n');
    return hi_comment;        
  }
:70gpc
    while (*++*src != quote)
    while (**src && **src != '\n' && *++*src != quote)
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘hi_c’:
st3.c:52:3: warning: this ‘if’ clause does not guard... [-Wmisleading-indentation]
   52 |   if (isspace(**src))
      |   ^~
st3.c:55:5: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘if’
   55 |     if (strncmp(*src, *kw, strlen(*kw)) == 0)
      |     ^~
st3.c:55:24: error: ‘kw’ undeclared (first use in this function); did you mean ‘kws’?
   55 |     if (strncmp(*src, *kw, strlen(*kw)) == 0)
      |                        ^~
      |                        kws
st3.c:55:24: note: each undeclared identifier is reported only once for each function it appears in
st3.c:57:35: warning: left-hand operand of comma expression has no effect [-Wunused-value]
   57 |         return *src += strlen(*kw), hi_keyword;
      |                                   ^
st3.c:29:16: warning: unused variable ‘kws’ [-Wunused-variable]
   29 |   static char *kws[] = {
      |                ^~~
st3.c: At top level:
st3.c:29:16: warning: ‘kws’ defined but not used [-Wunused-variable]
make: *** [Makefile:3: st3] Error 1
! bin/st3 st3.c
:50g20n
   50   };
   51 
   52   if (isspace(**src))
   53     return ++*src, hi_default;
   54 
   55     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   56       if (!isident((*src)[strlen(*kw)]))
   57         return *src += strlen(*kw), hi_keyword;
   58 
   59   if (isident(**src)) {
   60     while (isident(*++*src));
   61     return hi_default;
   62   }
   63 
   64   for (char **op = ops; *op; op++)
   65     if (strncmp(*src, *op, strlen(*op)) == 0)
   66       return *src += strlen(*op), hi_operator;
   67 
   68   if (**src == '"' || **src == '\'') {
   69     char quote = **src;
:54ga
  for (char **kw = kws; *kw; kw++)
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
$ bin/st3 st3.c
:68g40n
   68 
   69   if (**src == '"' || **src == '\'') {
   70     char quote = **src;
   71     while (**src && **src != '\n' && *++*src != quote)
   72       if (**src == '\\')
   73         ++*src;
   74     return ++*src, hi_literal;
   75   }
   76 
   77   if (**src == '#') {
   78     while (isspace(*++*src));
   79     for (char **pp = pps; *pp; pp++)
   80       if (strncmp(*src, *pp, strlen(*pp)) == 0)
   81         if (!isident((*src)[strlen(*pp)]))
   82           return *src += strlen(*pp), hi_keyword;
   83     return hi_default;
   84   }
   85 
   86   if (strncmp(*src, "//", 2)) {
   87     while (**src && *++*src != '\n');
   88     return hi_comment;
   89   }
   90 
   91   return ++*src, hi_default;
   92 }
   93 
   94 unsigned curr = 0;
   95 unsigned nlines = 0;
   96 char lines[65536][256] = {0};
   97 unsigned ncut = 0;
   98 char cut[256][256] = {0};
   99 
  100 int main(int argc, char **argv) {
  101   if (argc != 2)
  102     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
  103 
  104   char buf[64] = "e\n";
  105   char *bufp = buf;
  106   goto begin;
  107 
:74gpc2a
    return ++*src, hi_literal;
    if (**src == quote) 
      ++*src;
    return hi_literal;
:88gpc
  if (strncmp(*src, "//", 2)) {
  if (strncmp(*src, "//", 2) == 0) {
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
$ bin/st3 st3.c
:80g20n
   80     while (isspace(*++*src));
   81     for (char **pp = pps; *pp; pp++)
   82       if (strncmp(*src, *pp, strlen(*pp)) == 0)
   83         if (!isident((*src)[strlen(*pp)]))
   84           return *src += strlen(*pp), hi_keyword;
   85     return hi_default;
   86   }
   87 
   88   if (strncmp(*src, "//", 2) == 0) {
   89     while (**src && *++*src != '\n');
   90     return hi_comment;
   91   }
   92 
   93   return ++*src, hi_default;
   94 }
   95 
   96 unsigned curr = 0;
   97 unsigned nlines = 0;
   98 char lines[65536][256] = {0};
   99 unsigned ncut = 0;
:88g5y5d
:50g20n
   50   };
   51 
   52   if (isspace(**src))
   53     return ++*src, hi_default;
   54 
   55   for (char **kw = kws; *kw; kw++)
   56     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   57       if (!isident((*src)[strlen(*kw)]))
   58         return *src += strlen(*kw), hi_keyword;
   59 
   60   if (isident(**src)) {
   61     while (isident(*++*src));
   62     return hi_default;
   63   }
   64 
   65   for (char **op = ops; *op; op++)
   66     if (strncmp(*src, *op, strlen(*op)) == 0)
   67       return *src += strlen(*op), hi_operator;
   68 
   69   if (**src == '"' || **src == '\'') {
:55gx50g20n
   50   };
   51 
   52   if (isspace(**src))
   53     return ++*src, hi_default;
   54 
   55   if (strncmp(*src, "//", 2) == 0) {
   56     while (**src && *++*src != '\n');
   57     return hi_comment;
   58   }
   59 
   60   for (char **kw = kws; *kw; kw++)
   61     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   62       if (!isident((*src)[strlen(*kw)]))
   63         return *src += strlen(*kw), hi_keyword;
   64 
   65   if (isident(**src)) {
   66     while (isident(*++*src));
   67     return hi_default;
   68   }
   69 
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
$ bin/st3 st3.c
:68g5a

  if (isdigit(**src)) {
    while (isident(*++*src));           
    return hi_default;
  }
:65gpc
  if (isident(**src)) {
  if (isdigit(**src)) {
:70gpc
  if (isdigit(**src)) {
  if (isident(**src)) {
:67gpc
    return hi_default;
    return hi_literal;
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
$ bin/st3 st3.c
:
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
$ bin/st3 st3.c
:120g20n
  120     int nread;
  121     unsigned cnt;
  122     if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
  123       nread = 0, cnt = 1;
  124     bufp += nread;
  125 
  126     if (!strchr("gjkaicdyxnpewq", *bufp)) {
  127       printf("?\n");
  128       continue;
  129     }
  130 
  131     FILE *fp = NULL;
  132 
  133     switch (*bufp) {
  134     case 'g':
  135       curr = cnt - 1;
  136       break;
  137     case 'j':
  138       curr += cnt;
  139       break;
:100g20n
  100 
  101 unsigned curr = 0;
  102 unsigned nlines = 0;
  103 char lines[65536][256] = {0};
  104 unsigned ncut = 0;
  105 char cut[256][256] = {0};
  106 
  107 int main(int argc, char **argv) {
  108   if (argc != 2)
  109     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
  110 
  111   char buf[64] = "e\n";
  112   char *bufp = buf;
  113   goto begin;
  114 
  115   while(!feof(stdin)) {
  116     if (*++bufp == '\n')
  117       fputs("\033[m:", stdout), bufp = fgets(buf, sizeof(buf), stdin);
  118 
  119   begin:;
:116gpc
    if (*++bufp == '\n')
    if (*++bufp == '\n' || *bufp == '\0')
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
$ bin/st3 st3.c
:
?
:
?
:q
$ bin/st3 st2.c
:50g20n
   50     FILE *fp = NULL;
   51 
   52     switch (*bufp) {
   53     case 'g':
   54       curr = cnt - 1;
   55       break;
   56     case 'j':
   57       curr += cnt;
   58       break;
   59     case 'k':
   60       curr -= cnt;
   61       break;
   62     case 'd':
   63       nlines -= cnt;
   64       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
   65       memset(lines[nlines], 0, cnt * sizeof(*lines));
   66       break;
   67     case 'a':
   68       curr++;
   69     case 'i':
:20g20n
   20 unsigned curr = 0;
   21 unsigned nlines = 0;
   22 char lines[65536][256] = {0};
   23 unsigned ncut = 0;
   24 char cut[256][256] = {0};
   25 
   26 int main(int argc, char **argv) {
   27   if (argc != 2)
   28     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
   29 
   30   char buf[64] = "e\n";
   31   char *bufp = buf;
   32   goto begin;
   33 
   34   while(!feof(stdin)) {
   35     if (*++bufp == '\n')
   36       putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
   37 
   38   begin:;
   39     int nread;
:35gpc
    if (*++bufp == '\n')
    if (*++bufp == '\n' || *bufp == '\0')
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st3 st2.c
:100g20n
  100       case 'n':
  101         if (*lines[curr + n])
  102           printf("%5u ", curr + n + 1); // 65536 is 5 chars long
  103       case 'p':
  104         fputs(lines[curr + n], stdout);
  105         break;
  106       case 'x':
  107         memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
  108         break;
  109       case 'e':
  110         if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
  111           nlines = ++cnt;
  112         break;
  113       case 'w':
  114         cnt = nlines;
  115         fputs(lines[n], fp);
  116         break;
  117       }
  118 
  119     }
:120g20n
  120 
  121     if (fp && fclose(fp) == EOF)
  122       perror("fclose"), exit(EXIT_FAILURE);
  123   }
  124 }
:120g8a
    switch (*bufp) {
      case 'g':
        curr = cnt - 1;
      case 'j': 
      case 'a':
      case 'c':
      case 'n':
      case 'p':
:128g6a
        curr += cnt;
      case 'k':
        curr -= cnt;
        break;
      case 'e':
      case 'w':
:n 
  129         curr += cnt;
:120g120n
  120 
  121     switch (*bufp) {
  122       case 'g':
  123         curr = cnt - 1;
  124       case 'j':
  125       case 'a':
  126       case 'c':
  127       case 'n':
  128       case 'p':
  129         curr += cnt;
  130       case 'k':
  131         curr -= cnt;
  132         break;
  133       case 'e':
  134       case 'w':
  135     if (fp && fclose(fp) == EOF)
  136       perror("fclose"), exit(EXIT_FAILURE);
  137   }
  138 }
:134g2ca 
        if (fclose(fp) == EOF)
          perror("fclose"), exit(EXIT_FAILURE);
      }
:123ga
        break;
:130gpa
        curr += cnt;
        break;
:120g30n
  120 
  121     switch (*bufp) {
  122       case 'g':
  123         curr = cnt - 1;
  124         break;
  125       case 'j':
  126       case 'a':
  127       case 'c':
  128       case 'n':
  129       case 'p':
  130         curr += cnt;
  131         break;
  132       case 'k':
  133         curr -= cnt;
  134         break;
  135       case 'e':
  136         if (fclose(fp) == EOF)
  137       }
  138           perror("fclose"), exit(EXIT_FAILURE);
  139       perror("fclose"), exit(EXIT_FAILURE);
  140   }
  141 }
:137gdjd120g30n
  120 
  121     switch (*bufp) {
  122       case 'g':
  123         curr = cnt - 1;
  124         break;
  125       case 'j':
  126       case 'a':
  127       case 'c':
  128       case 'n':
  129       case 'p':
  130         curr += cnt;
  131         break;
  132       case 'k':
  133         curr -= cnt;
  134         break;
  135       case 'e':
  136         if (fclose(fp) == EOF)
  137           perror("fclose"), exit(EXIT_FAILURE);
  138   }
  139 }
:137ga
      }
:50g20n
   50     FILE *fp = NULL;
   51 
   52     switch (*bufp) {
   53     case 'g':
   54       curr = cnt - 1;
   55       break;
   56     case 'j':
   57       curr += cnt;
   58       break;
   59     case 'k':
   60       curr -= cnt;
   61       break;
   62     case 'd':
   63       nlines -= cnt;
   64       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
   65       memset(lines[nlines], 0, cnt * sizeof(*lines));
   66       break;
   67     case 'a':
   68       curr++;
   69     case 'i':
:53g9d
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st3 st2.c
:20g20n
   20 unsigned curr = 0;
   21 unsigned nlines = 0;
   22 char lines[65536][256] = {0};
   23 unsigned ncut = 0;
   24 char cut[256][256] = {0};
   25 
   26 int main(int argc, char **argv) {
   27   if (argc != 2)
   28     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
   29 
   30   char buf[64] = "e\n";
   31   char *bufp = buf;
   32   goto begin;
   33 
   34   while(!feof(stdin)) {
   35     if (*++bufp == '\n' || *bufp == '\0')
   36       putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
   37 
   38   begin:;
   39     int nread;
:32gd
:37gd
:33gp
  while(!feof(stdin)) {
:34gpc
    if (*++bufp == '\n' || *bufp == '\0')
    if (*bufp == '\n') {  
:35gpca
      putchar(':'), bufp = fgets(buf, sizeof(buf), stdin);
      putchar(':'); 
      bufp = fgets(buf, sizeof(buf), stdin);
:n
   36       bufp = fgets(buf, sizeof(buf), stdin);
:a
      continue;
:n
   37       continue;
:a
    }
:20g20n
   20 unsigned curr = 0;
   21 unsigned nlines = 0;
   22 char lines[65536][256] = {0};
   23 unsigned ncut = 0;
   24 char cut[256][256] = {0};
   25 
   26 int main(int argc, char **argv) {
   27   if (argc != 2)
   28     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
   29 
   30   char buf[64] = "e\n";
   31   char *bufp = buf;
   32 
   33   while(!feof(stdin)) {
   34     if (*bufp == '\n') {
   35       putchar(':');
   36       bufp = fgets(buf, sizeof(buf), stdin);
   37       continue;
   38     }
   39 
:w
:40g20n
   40     int nread;
   41     unsigned cnt;
   42     if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
   43       nread = 0, cnt = 1;
   44     bufp += nread;
   45 
   46     if (!strchr("gjkaicdyxnpewq", *bufp)) {
   47       printf("?\n");
   48       continue;
   49     }
   50 
   51     FILE *fp = NULL;
   52 
   53     switch (*bufp) {
   54     case 'd':
   55       nlines -= cnt;
   56       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
   57       memset(lines[nlines], 0, cnt * sizeof(*lines));
   58       break;
   59     case 'a':
:47gpa
      printf("?\n");
      bufp++;
:43gpa
      nread = 0, cnt = 1;
                         
:44gpd

:48gpca
      bufp++;
      if (bufp != '\n')
        bufp++;
:100g20n
  100       case 'x':
  101         memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
  102         break;
  103       case 'e':
  104         if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
  105           nlines = ++cnt;
  106         break;
  107       case 'w':
  108         cnt = nlines;
  109         fputs(lines[n], fp);
  110         break;
  111       }
  112 
  113     }
  114 
  115     switch (*bufp) {
  116       case 'g':
  117         curr = cnt - 1;
  118         break;
  119       case 'j':
:120g20n
  120       case 'a':
  121       case 'c':
  122       case 'n':
  123       case 'p':
  124         curr += cnt;
  125         break;
  126       case 'k':
  127         curr -= cnt;
  128         break;
  129       case 'e':
  130         if (fclose(fp) == EOF)
  131           perror("fclose"), exit(EXIT_FAILURE);
  132       }
  133   }
  134 }
:115g18c
    switch (*bufp) {
    case 'g':
      curr = cnt - 1;
    case 'j; 
    case 'a':
    case 'c':
    case 'n':
    case 'p':
      curr += cnt;
    case 'k':
      curr -= cnt;
      break;
    case 'e':
      if (fclose(fp) == EOF)
        perror("fclose"), exit(EXIT_FAILURE);
    }


:117gpa
      curr = cnt - 1;
      break;
:124gpa
      curr += cnt;
      break;
:1332p
      break;
    case 'k':
      curr -= cnt;
      break;
    case 'e':
      if (fclose(fp) == EOF)
        perror("fclose"), exit(EXIT_FAILURE);
    }


  }
}
:133g2p


:133g2d
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
st2.c: In function ‘main’:
st2.c:48:16: error: comparison between pointer and integer [-Werror]
   48 |       if (bufp != '\n')
      |                ^~
st2.c:119:10: error: missing terminating ' character [-Werror]
  119 |     case 'j;
      |          ^
st2.c:119:10: error: missing terminating ' character
  119 |     case 'j;
      |          ^~~
st2.c:120:5: error: expected expression before ‘case’
  120 |     case 'a':
      |     ^~~~
cc1: all warnings being treated as errors
make: *** [Makefile:7: st2] Error 1
! bin/st3 st2.c
:48gpc
      if (bufp != '\n')
      if (*bufp != '\n')
:119gpc
    case 'j;
    case 'j':
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st3 st2.c
:120g20n
  120     case 'a':
  121     case 'c':
  122     case 'n':
  123     case 'p':
  124       curr += cnt;
  125       break;
  126     case 'k':
  127       curr -= cnt;
  128       break;
  129     case 'e':
  130       if (fclose(fp) == EOF)
  131         perror("fclose"), exit(EXIT_FAILURE);
  132     }
  133   }
  134 }
:133g2a

  bufp++;
:20k20n
  114 
  115     switch (*bufp) {
  116     case 'g':
  117       curr = cnt - 1;
  118       break;
  119     case 'j':
  120     case 'a':
  121     case 'c':
  122     case 'n':
  123     case 'p':
  124       curr += cnt;
  125       break;
  126     case 'k':
  127       curr -= cnt;
  128       break;
  129     case 'e':
  130       if (fclose(fp) == EOF)
  131         perror("fclose"), exit(EXIT_FAILURE);
  132     }
  133   }
:20k20n
   94       case 'n':
   95         if (*lines[curr + n])
   96           printf("%5u ", curr + n + 1); // 65536 is 5 chars long
   97       case 'p':
   98         fputs(lines[curr + n], stdout);
   99         break;
  100       case 'x':
  101         memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
  102         break;
  103       case 'e':
  104         if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
  105           nlines = ++cnt;
  106         break;
  107       case 'w':
  108         cnt = nlines;
  109         fputs(lines[n], fp);
  110         break;
  111       }
  112 
  113     }
:112gd
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
$ bin/st3 st2.c
:130g8n
  130         perror("fclose"), exit(EXIT_FAILURE);
  131     }
  132   }
  133 
  134   bufp++;
  135 }
:133gdd
:131gp2a
    }

    bufp++;
:wq
$ bin/st2 st3.c
:100g20n
  100 
  101 unsigned curr = 0;
  102 unsigned nlines = 0;
  103 char lines[65536][256] = {0};
  104 unsigned ncut = 0;
  105 char cut[256][256] = {0};
  106 
  107 int main(int argc, char **argv) {
  108   if (argc != 2)
  109     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
  110 
  111   char buf[64] = "e\n";
  112   char *bufp = buf;
  113   goto begin;
  114 
  115   while(!feof(stdin)) {
  116     if (*++bufp == '\n' || *bufp == '\0')
  117       fputs("\033[m:", stdout), bufp = fgets(buf, sizeof(buf), stdin);
  118 
  119   begin:;
:116gpcc3a 
    if (*++bufp == '\n' || *bufp == '\0')
    if (*bufp == '\n') {
      fputs("\033[m:", stdout);
      bufp = fgets(buf, sizeof(buf), stdin);
      continue;
    }
:kk20n
  121       continue;
  122     }
  123     int nread;
  124     unsigned cnt;
  125     if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
  126       nread = 0, cnt = 1;
  127     bufp += nread;
  128 
  129     if (!strchr("gjkaicdyxnpewq", *bufp)) {
  130       printf("?\n");
  131       continue;
  132     }
  133 
  134     FILE *fp = NULL;
  135 
  136     switch (*bufp) {
  137     case 'g':
  138       curr = cnt - 1;
  139       break;
  140     case 'j':
:122ga

:166gp
      if (fp == NULL)
:116gp
    if (*++bufp == '\n' || *bufp == '\0')
:kd
:130p2i 
    if (*bufp == '\n') {
      fputs("\033[m:", stdout);
  begin:;
      bufp = fgets(buf, sizeof(buf), stdin);
      continue;
    }

    int nread;
    unsigned cnt;
    if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
      nread = 0, cnt = 1;
    bufp += nread;

    if (!strchr("gjkaicdyxnpewq", *bufp)) {
      printf("?\n");
      continue;
    }

    FILE *fp = NULL;

    switch (*bufp) {
    case 'g':
      curr = cnt - 1;
      break;
    case 'j':
      curr += cnt;
      break;
    case 'k':
      curr -= cnt;
      break;
    case 'd':
      nlines -= cnt;
      memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
      memset(lines[nlines], 0, cnt * sizeof(*lines));
      break;
    case 'a':
      curr++;
    case 'i':
      memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
      nlines += cnt;
      break;
    case 'y':
      memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
      break;
    case 'x':
      memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
      nlines += cnt * ncut;
    case 'e':
      fp = fopen(argv[1], "r");
      if (fp == NULL)
        perror("fopen"), exit(EXIT_FAILURE);
      break;
    case 'w':
      fp = fopen(argv[1], "w");
      if (fp == NULL)
        perror("fopen"), exit(EXIT_FAILURE);
      break;
    case 'q':
      exit(EXIT_SUCCESS);
    }

    for (unsigned n = 0; n < cnt; n++) {
      switch (*bufp) {
      case 'a':
      case 'i':
      case 'c':
        fgets(lines[curr + n], sizeof(*lines), stdin);
        break;
      case 'n':
        if (*lines[curr + n])
          printf("\033[2;3m%5u ", curr + n + 1); // 65536 is 5 chars long
      case 'p': {
        char *end = lines[curr + n];
        for (char *start = end; *start; start = end) {
          fputs(hi_c(&end), stdout);
          printf("%.*s", (int)(end - start), start);
        }
      } break;
      case 'x':
        memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
        break;
      case 'e':
        if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
          nlines = ++cnt;
        break;
      case 'w':
        cnt = nlines;
        fputs(lines[n], fp);
        break;
      }

    }

    if (fp && fclose(fp) == EOF)
      perror("fclose"), exit(EXIT_FAILURE);
  }
}
fish: Job 1, 'bin/st2 st3.c' terminated by signal SIGSEGV (Address boundary error)
! bin/st2 st3.c
:116gpkcc3a
    if (*++bufp == '\n' || *bufp == '\0')
    if (*bufp == '\n')
      fputs("\033[m:", stdout);
      bufp = fgets(buf, sizeof(buf), stdin);
      continue;
    }
:116gc
    if (*bufp == '\n') {
:130gp2i
      printf("?\n");
      if (*bufp != '\n')
        bufp++;
:20n
  131       if (*bufp != '\n')
  132         bufp++;
  133       continue;
  134     }
  135 
  136     FILE *fp = NULL;
  137 
  138     switch (*bufp) {
  139     case 'g':
  140       curr = cnt - 1;
  141       break;
  142     case 'j':
  143       curr += cnt;
  144       break;
  145     case 'k':
  146       curr -= cnt;
  147       break;
  148     case 'd':
  149       nlines -= cnt;
  150       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
:w
:139g9d
:20n
  139     case 'd':
  140       nlines -= cnt;
  141       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
  142       memset(lines[nlines], 0, cnt * sizeof(*lines));
  143       break;
  144     case 'a':
  145       curr++;
  146     case 'i':
  147       memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
  148       nlines += cnt;
  149       break;
  150     case 'y':
  151       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  152       break;
  153     case 'x':
  154       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  155       nlines += cnt * ncut;
  156     case 'e':
  157       fp = fopen(argv[1], "r");
  158       if (fp == NULL)
:10j10n
  169 
  170     for (unsigned n = 0; n < cnt; n++) {
  171       switch (*bufp) {
  172       case 'a':
  173       case 'i':
  174       case 'c':
  175         fgets(lines[curr + n], sizeof(*lines), stdin);
  176         break;
  177       case 'n':
  178         if (*lines[curr + n])
:20j20n
  199 
  200     }
  201 
  202     if (fp && fclose(fp) == EOF)
  203       perror("fclose"), exit(EXIT_FAILURE);
  204   }
  205 }
:202gcc18i
    switch (*bufp) {
      case 'g':
      curr = cnt - 1;
    case 'j':
    case 'a':
    case 'c':
    case 'n':
    case 'p':
      curr += cnt;
      break;
    case 'k':
      curr -= cnt;
      break;
    case 'e':
    case 'w':
      if (fclose(fp) == EOF)
        perror("fclose"), exit(EXIT_FAILURE);
    }

    bufp++;
:200g40n
  200     }
  201 
  202     switch (*bufp) {
  203       case 'g':
  204       curr = cnt - 1;
  205     case 'j':
  206     case 'a':
  207     case 'c':
  208     case 'n':
  209     case 'p':
  210       curr += cnt;
  211       break;
  212     case 'k':
  213       curr -= cnt;
  214       break;
  215     case 'e':
  216     case 'w':
  217       if (fclose(fp) == EOF)
  218         perror("fclose"), exit(EXIT_FAILURE);
  219     }
  220 
  221     bufp++;
  222   }
  223 }
:203gc 
    case 'g':
:204gpi
      curr = cnt - 1;
      break;
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘main’:
st3.c:158:11: error: ‘fpncut’ undeclared (first use in this function); did you mean ‘ncut’?
  158 |       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
      |           ^~~~~~
      |           ncut
st3.c:158:11: note: each undeclared identifier is reported only once for each function it appears in
st3.c:158:17: error: expected ‘)’ before ‘]’ token
  158 |       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
      |          ~      ^
      |                 )
st3.c:158:17: error: expected statement before ‘]’ token
st3.c:158:7: warning: this ‘if’ clause does not guard... [-Wmisleading-indentation]
  158 |       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
      |       ^~
st3.c:158:18: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘if’
  158 |       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
      |                  ^
st3.c:158:18: error: expected expression before ‘,’ token
st3.c:158:18: warning: left-hand operand of comma expression has no effect [-Wunused-value]
st3.c:158:31: warning: left-hand operand of comma expression has no effect [-Wunused-value]
  158 |       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
      |                               ^
st3.c:158:31: warning: statement with no effect [-Wunused-value]
st3.c:158:65: error: expected ‘;’ before ‘)’ token
  158 |       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
      |                                                                 ^
      |                                                                 ;
st3.c:158:65: error: expected statement before ‘)’ token
st3.c:160:5: error: duplicate case value
  160 |     case 'e':
      |     ^~~~
st3.c:156:5: note: previously used here
  156 |     case 'e':
      |     ^~~~
st3.c: At top level:
st3.c:210:4: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before 'e'
  210 | se 'e':
      |    ^~~
st3.c:214:5: error: expected identifier or ‘(’ before ‘}’ token
  214 |     }
      |     ^
st3.c:216:9: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘++’ token
  216 |     bufp++;
      |         ^~
st3.c:217:3: error: expected identifier or ‘(’ before ‘}’ token
  217 |   }
      |   ^
st3.c:218:1: error: expected identifier or ‘(’ before ‘}’ token
  218 | }
      | ^
make: *** [Makefile:3: st3] Error 1
! bin/st2 st3.c
:158gkk4n
  156     case 'e':
  157       fp = fopen(argv[1], "r");
  158       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
  159       nlines += cnt * ncut;
:120g
:40n
  120       continue;
  121     }
  122   begin:;
  123     int nread;
  124     unsigned cnt;
  125     if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
  126       nread = 0, cnt = 1;
  127     bufp += nread;
  128 
  129     if (!strchr("gjkaicdyxnpewq", *bufp)) {
  130       printf("?\n");
  131       if (*bufp != '\n')
  132         bufp++;
  133       continue;
  134     }
  135 
  136     FILE *fp = NULL;
  137 
  138     switch (*bufp) {
  139     case 'd':
  140       nlines -= cnt;
  141       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
  142       memset(lines[nlines], 0, cnt * sizeof(*lines));
  143       break;
  144     case 'a':
  145       curr++;
  146     case 'i':
  147       memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
  148       nlines += cnt;
  149       break;
  150     case 'y':
  151       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  152       break;
  153     case 'x':
  154       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  155       nlines += cnt * ncut;
  156     case 'e':
  157       fp = fopen(argv[1], "r");
  158       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
  159       nlines += cnt * ncut;
:150g20n
  150     case 'y':
  151       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  152       break;
  153     case 'x':
  154       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  155       nlines += cnt * ncut;
  156     case 'e':
  157       fp = fopen(argv[1], "r");
  158       if (fpncut], lines[curr], (nlines - curr) * sizeof(*lines));
  159       nlines += cnt * ncut;
  160     case 'e':
  161       fp = fopen(argv[1], "r");
  162       if (fp == NULL)
  163         perror("fopen"), exit(EXIT_FAILURE);
  164       break;
  165     case 'w':
  166       fp = fopen(argv[1], "w");
  167       if (fp == NULL)
  168         perror("fopen"), exit(EXIT_FAILURE);
  169       break;
:156g4dwq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c:206:4: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before 'e'
  206 | se 'e':
      |    ^~~
st3.c:210:5: error: expected identifier or ‘(’ before ‘}’ token
  210 |     }
      |     ^
st3.c:212:9: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘++’ token
  212 |     bufp++;
      |         ^~
st3.c:213:3: error: expected identifier or ‘(’ before ‘}’ token
  213 |   }
      |   ^
st3.c:214:1: error: expected identifier or ‘(’ before ‘}’ token
  214 | }
      | ^
make: *** [Makefile:3: st3] Error 1
! bin/st2 st3.c
:206gkkkkk20n
  201 
  202     if (fp && fclose(fp) == EOF)
  203       perror("fclose"), exit(EXIT_FAILURE);
  204   }
  205 }
  206 se 'e':
  207     case 'w':
  208       if (fclose(fp) == EOF)
  209         perror("fclose"), exit(EXIT_FAILURE);
  210     }
  211 
  212     bufp++;
  213   }
  214 }
:kkkk20n
:200g20n
  200     }
  201 
  202     if (fp && fclose(fp) == EOF)
  203       perror("fclose"), exit(EXIT_FAILURE);
  204   }
  205 }
  206 se 'e':
  207     case 'w':
  208       if (fclose(fp) == EOF)
  209         perror("fclose"), exit(EXIT_FAILURE);
  210     }
  211 
  212     bufp++;
  213   }
  214 }
:200g21a

    switch (*bufp) {
    case 'g':
      curr = cnt - 1;
      break;
    case 'j':
    case 'a':
    case 'c':
    case 'n':
    case 'p':
      curr += cnt;
      break;
    case 'k':
      curr -= cnt;
      break;
    case 'e':
    case 'w':     
      if (fclose(fp) == EOF)
        perror("fclose"), exit(EXIT_FAILURE);
    }

:a
    bufp++;
:20n
  224     if (fp && fclose(fp) == EOF)
  225       perror("fclose"), exit(EXIT_FAILURE);
  226   }
  227 }
  228 se 'e':
  229     case 'w':
  230       if (fclose(fp) == EOF)
  231         perror("fclose"), exit(EXIT_FAILURE);
  232     }
  233 
  234     bufp++;
  235   }
  236 }
:224g10d
:200g40n
  200     }
  201 
  202     switch (*bufp) {
  203     case 'g':
  204       curr = cnt - 1;
  205       break;
  206     case 'j':
  207     case 'a':
  208     case 'c':
  209     case 'n':
  210     case 'p':
  211       curr += cnt;
  212       break;
  213     case 'k':
  214       curr -= cnt;
  215       break;
  216     case 'e':
  217     case 'w':
  218       if (fclose(fp) == EOF)
  219         perror("fclose"), exit(EXIT_FAILURE);
  220     }
  221 
  222 
  223     bufp++;
  224     bufp++;
  225   }
  226 }
:222gdd
:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
$ bin/st3 st3.c
:122gpk
  begin:;
:c

:wq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
st3.c: In function ‘main’:
st3.c:113:3: error: label ‘begin’ used but not defined
  113 |   goto begin;
      |   ^~~~
make: *** [Makefile:3: st3] Error 1
! bin/st3 st3.c
:113gkk8n
  111   char buf[64] = "e\n";
  112   char *bufp = buf;
  113   goto begin;
  114 
  115   while(!feof(stdin)) {
  116     if (*bufp == '\n') {
  117       fputs("\033[m:", stdout);
  118 
:113gdwq
$ make st3
mkdir -p bin
gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
$ bin/st3 st2.c
:100g40n
  100       case 'x':
  101         memcpy(lines[curr + n * ncut], *cut, ncut * sizeof(*cut));
  102         break;
  103       case 'e':
  104         if (fgets(lines[n], sizeof(*lines), fp) != NULL)  
  105           nlines = ++cnt;
  106         break;
  107       case 'w':
  108         cnt = nlines;
  109         fputs(lines[n], fp);
  110         break;
  111       }
  112     }
  113 
  114     switch (*bufp) {
  115     case 'g':
  116       curr = cnt - 1;
  117       break;
  118     case 'j':
  119     case 'a':
  120     case 'c':
  121     case 'n':
  122     case 'p':
  123       curr += cnt;
  124       break;
  125     case 'k':
  126       curr -= cnt;
  127       break;
  128     case 'e':
  129       if (fclose(fp) == EOF)
  130         perror("fclose"), exit(EXIT_FAILURE);
  131     }
  132 
  133     bufp++;
  134   }
  135 }
:128gpi
    case 'e':
    case 'w':
:wq
$ make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
& rm bin/st3
& mv st3.c st2.c
& make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
& bin/st2 Makefile
:8n
    1 st3:
    2 	mkdir -p bin
    3 	gcc -O2 -Wall -pedantic -std=c99 st3.c -o bin/st3
    4 
    5 st2:
    6 	mkdir -p bin
    7 	gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
    8 
:g4dwq
& bin/st2 README.md 
:8n
    1 # #todo name
    2 
    3 _Minimal text editor bootstrapped from `cat`_
    4 
    5 The bootstrapping process consists of several stages:
    6 
    7 0. Write a bare-bones line editor on paper. Man pages are fair play.
    8 1. Use `cat` with shell redirection to write the listing from stage 0 to a file. Tweak and repeat until it builds and runs.
:n
    9 2. Use the bare-bones line editor from stage 1 to bootstrap convenience features such as error handling and copy-paste.
:kpkc
2. Use the bare-bones line editor from stage 1 to bootstrap convenience features such as error handling and copy-paste.
2. Use the bare-bones line editor from stage 1 to bootstrap convenience features such as copy-paste and syntax highlighting.
:wq
& bin/st2 st2.c
:100g20n
  100 
  101 unsigned curr = 0;
  102 unsigned nlines = 0;
  103 char lines[65536][256] = {0};
  104 unsigned ncut = 0;
  105 char cut[256][256] = {0};
  106 
  107 int main(int argc, char **argv) {
  108   if (argc != 2)
  109     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
  110 
  111   char buf[64] = "e\n";
  112   char *bufp = buf;
  113 
  114   while(!feof(stdin)) {
  115     if (*bufp == '\n') {
  116       fputs("\033[m:", stdout);
  117 
  118       bufp = fgets(buf, sizeof(buf), stdin);
  119       continue;
:20j20n
  140       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
  141       memset(lines[nlines], 0, cnt * sizeof(*lines));
  142       break;
  143     case 'a':
  144       curr++;
  145     case 'i':
  146       memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
  147       nlines += cnt;
  148       break;
  149     case 'y':
  150       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  151       break;
  152     case 'x':
  153       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  154       nlines += cnt * ncut;
  155     case 'e':
  156       fp = fopen(argv[1], "r");
  157       if (fp == NULL)
  158         perror("fopen"), exit(EXIT_FAILURE);
  159       break;
:20n
  160     case 'w':
  161       fp = fopen(argv[1], "w");
  162       if (fp == NULL)
  163         perror("fopen"), exit(EXIT_FAILURE);
  164       break;
  165     case 'q':
  166       exit(EXIT_SUCCESS);
  167     }
  168 
  169     for (unsigned n = 0; n < cnt; n++) {
  170       switch (*bufp) {
  171       case 'a':
  172       case 'i':
  173       case 'c':
  174         fgets(lines[curr + n], sizeof(*lines), stdin);
  175         break;
  176       case 'n':
  177         if (*lines[curr + n])
  178           printf("\033[2;3m%5u ", curr + n + 1); // 65536 is 5 chars long
  179       case 'p': {
:178gpkc
          printf("\033[2;3m%5u ", curr + n + 1); // 65536 is 5 chars long
          printf("\033[;2;3m%5u ", curr + n + 1); // 65536 is 5 chars long
:wq
& bin/st2 Makefile
:8n
    1 st2:
    2 	mkdir -p bin
    3 	gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
    4 
    5 st1:
    6 	mkdir -p bin
    7 	gcc -O2 -Wall -Werror -pedantic -std=c99 st1.c -o bin/st1
    8 
:7g3a

st0:
	echo "if only"
:wq
& bin/st2 st2.c
:100g20n
  100 
  101 unsigned curr = 0;
  102 unsigned nlines = 0;
  103 char lines[65536][256] = {0};
  104 unsigned ncut = 0;
  105 char cut[256][256] = {0};
  106 
  107 int main(int argc, char **argv) {
  108   if (argc != 2)
  109     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
  110 
  111   char buf[64] = "e\n";
  112   char *bufp = buf;
  113 
  114   while(!feof(stdin)) {
  115     if (*bufp == '\n') {
  116       fputs("\033[m:", stdout);
  117 
  118       bufp = fgets(buf, sizeof(buf), stdin);
  119       continue;
:101gd110gi
  unsigned curr = 0;
:117gpkd

:114gpkc
  while(!feof(stdin)) {
  while (!feof(stdin)) {
:wq
& make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
& bin/st2 st2.c
:20g20n
   20 
   21 char *hi_default = "\033[m";
   22 char *hi_keyword = "\033[;1m";
   23 char *hi_comment = "\033[;2;3m";
   24 char *hi_operator = "\033[;2m";
   25 char *hi_literal = "\033[;3m";
   26 
   27 int isident(int c) { return c == '_' || isalnum(c); }
   28 char *hi_c(char **src) {
   29   static char *kws[] = {
   30     "auto", "break", "case", "char", "const", "continue",
   31     "default", "do", "double", "else", "enum", "extern",
   32     "float", "for", "goto", "if", "inline", "int",
   33     "long", "register", "restrict", "return", "short", "signed",
   34     "sizeof", "static", "struct", "switch", "true", "typedef",
   35     "union", "unsigned", "void", "volatile", "while", "_Bool",
   36     "_Complex", "_Imaginary", NULL,
   37   };
   38   static char *pps[] = {
   39     "if", "elif", "else", "endif", "ifdef", "ifndef",
:34g3c
    "sizeof", "static", "struct", "switch", "typedef", "union",
    "unsigned", "void", "volatile", "while", "_Bool", "_Complex",
    "_Imaginary", NULL,
:wq
& make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
& bin/st2 st2.c
:100g20n
  100 
  101 unsigned nlines = 0;
  102 char lines[65536][256] = {0};
  103 unsigned ncut = 0;
  104 char cut[256][256] = {0};
  105 
  106 int main(int argc, char **argv) {
  107   if (argc != 2)
  108     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
  109 
  110   unsigned curr = 0;
  111   char buf[64] = "e\n";
  112   char *bufp = buf;
  113 
  114   while (!feof(stdin)) {
  115     if (*bufp == '\n') {
  116       fputs("\033[m:", stdout);
  117       bufp = fgets(buf, sizeof(buf), stdin);
  118       continue;
  119     }
:20n
  120 
  121     int nread;
  122     unsigned cnt;
  123     if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
  124       nread = 0, cnt = 1;
  125     bufp += nread;
  126 
  127     if (!strchr("gjkaicdyxnpewq", *bufp)) {
  128       printf("?\n");
  129       if (*bufp != '\n')
  130         bufp++;
  131       continue;
  132     }
  133 
  134     FILE *fp = NULL;
  135 
  136     switch (*bufp) {
  137     case 'd':
  138       nlines -= cnt;
  139       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
:20n
  140       memset(lines[nlines], 0, cnt * sizeof(*lines));
  141       break;
  142     case 'a':
  143       curr++;
  144     case 'i':
  145       memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
  146       nlines += cnt;
  147       break;
  148     case 'y':
  149       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  150       break;
  151     case 'x':
  152       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  153       nlines += cnt * ncut;
  154     case 'e':
  155       fp = fopen(argv[1], "r");
  156       if (fp == NULL)
  157         perror("fopen"), exit(EXIT_FAILURE);
  158       break;
  159     case 'w':
:146g3a
    case 'c':
      for (unsigned n = 0; n < cnt; n++)
        fgets(lines[curr], sizeof(*lines), stdin);
:148gc
      for (unsigned last = curr + cnt; curr < last; curr++)
:140g20n
  140       memset(lines[nlines], 0, cnt * sizeof(*lines));
  141       break;
  142     case 'a':
  143       curr++;
  144     case 'i':
  145       memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
  146       nlines += cnt;
  147     case 'c':
  148       for (unsigned last = curr + cnt; curr < last; curr++)
  149         fgets(lines[curr], sizeof(*lines), stdin);
  150       break;
  151     case 'y':
  152       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  153       break;
  154     case 'x':
  155       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  156       nlines += cnt * ncut;
  157     case 'e':
  158       fp = fopen(argv[1], "r");
  159       if (fp == NULL)
:156g2a
      for (unsigned last = curr + cnt * ncut; curr < last; curr += ncut)
        memcpy(lines[curr], *cut, ncut * sizeof(*cut));
:150g20n
  150       break;
  151     case 'y':
  152       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  153       break;
  154     case 'x':
  155       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  156       nlines += cnt * ncut;
  157       for (unsigned last = curr + cnt * ncut; curr < last; curr += ncut)
  158         memcpy(lines[curr], *cut, ncut * sizeof(*cut));
  159     case 'e':
  160       fp = fopen(argv[1], "r");
  161       if (fp == NULL)
  162         perror("fopen"), exit(EXIT_FAILURE);
  163       break;
  164     case 'w':
  165       fp = fopen(argv[1], "w");
  166       if (fp == NULL)
  167         perror("fopen"), exit(EXIT_FAILURE);
  168       break;
  169     case 'q':
:162ga
      for (nlines = 0; fgets(lines[nlines], sizeof(*lines), fp); nlines++);
:163g2a
      if (fclose(fp) == EOF)
        perror("fclose"), exit(EXIT_FAILURE);
:160g20n
  160       fp = fopen(argv[1], "r");
  161       if (fp == NULL)
  162         perror("fopen"), exit(EXIT_FAILURE);
  163       for (nlines = 0; fgets(lines[nlines], sizeof(*lines), fp); nlines++);
  164       if (fclose(fp) == EOF)
  165         perror("fclose"), exit(EXIT_FAILURE);
  166       break;
  167     case 'w':
  168       fp = fopen(argv[1], "w");
  169       if (fp == NULL)
  170         perror("fopen"), exit(EXIT_FAILURE);
  171       break;
  172     case 'q':
  173       exit(EXIT_SUCCESS);
  174     }
  175 
  176     for (unsigned n = 0; n < cnt; n++) {
  177       switch (*bufp) {
  178       case 'a':
  179       case 'i':
:170g3a
      for (unsigned n = 0; n < nlines; n++)
        fputs(lines[n], fp);  
      if (fclose(fp) == EOF)
:i
        perror("fclose"), exit(EXIT_FAILURE);
:165g30n
  165         perror("fclose"), exit(EXIT_FAILURE);
  166       break;
  167     case 'w':
  168       fp = fopen(argv[1], "w");
  169       if (fp == NULL)
  170         perror("fopen"), exit(EXIT_FAILURE);
  171       for (unsigned n = 0; n < nlines; n++)
  172         fputs(lines[n], fp);
  173       if (fclose(fp) == EOF)
  174         perror("fclose"), exit(EXIT_FAILURE);
  175       break;
  176     case 'q':
  177       exit(EXIT_SUCCESS);
  178     }
  179 
  180     for (unsigned n = 0; n < cnt; n++) {
  181       switch (*bufp) {
  182       case 'a':
  183       case 'i':
  184       case 'c':
  185         fgets(lines[curr + n], sizeof(*lines), stdin);
  186         break;
  187       case 'n':
  188         if (*lines[curr + n])
  189           printf("\033[;2;3m%5u ", curr + n + 1); // 65536 is 5 chars long
  190       case 'p': {
  191         char *end = lines[curr + n];
  192         for (char *start = end; *start; start = end) {
  193           fputs(hi_c(&end), stdout);
  194           printf("%.*s", (int)(end - start), start);
:w
:136g9a
    case 'g':
      curr = cnt - 1;
      break;
    case 'j':
      curr += cnt;
      break;
    case 'k':
      curr -= cnt;
      break;
:150g20n
  150       break;
  151     case 'a':
  152       curr++;
  153     case 'i':
  154       memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
  155       nlines += cnt;
  156     case 'c':
  157       for (unsigned last = curr + cnt; curr < last; curr++)
  158         fgets(lines[curr], sizeof(*lines), stdin);
  159       break;
  160     case 'y':
  161       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  162       break;
  163     case 'x':
  164       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  165       nlines += cnt * ncut;
  166       for (unsigned last = curr + cnt * ncut; curr < last; curr += ncut)
  167         memcpy(lines[curr], *cut, ncut * sizeof(*cut));
  168     case 'e':
  169       fp = fopen(argv[1], "r");
:167g11a
        break;
    case 'n':
    case 'p':    
      for (unsigned last = curr + cnt; curr < last; curr++) {
        if (*bufp == 'n' && *lines[curr])
          printf("\033[;2;3m%5u ", curr + 1); // 65536 is 5 chars long
        char *end = lines[curr];
        for (char *start = end; *start; start = end) {
          fputs(hi_c(&end), stdout);
          printf("%.*s", (int)(end - start), start);
        }
:2i
      }
      break;
:w
:e
:182gp
      fp = fopen(argv[1], "r");
:182gc
      fp = fopen(argv[1], *bufp == 'e' ? "r" : "w");
:181gi
    case 'e':
:kkkkk20n
  176           fputs(hi_c(&end), stdout);
  177           printf("%.*s", (int)(end - start), start);
  178         }
  179       }
  180       break;
  181     case 'e':
  182     case 'e':
  183       fp = fopen(argv[1], *bufp == 'e' ? "r" : "w");
  184       if (fp == NULL)
  185         perror("fopen"), exit(EXIT_FAILURE);
  186       for (nlines = 0; fgets(lines[nlines], sizeof(*lines), fp); nlines++);
  187       if (fclose(fp) == EOF)
  188         perror("fclose"), exit(EXIT_FAILURE);
  189       break;
  190     case 'w':
  191       fp = fopen(argv[1], "w");
  192       if (fp == NULL)
  193         perror("fopen"), exit(EXIT_FAILURE);
  194       for (unsigned n = 0; n < nlines; n++)
  195         fputs(lines[n], fp);
:182gc
    case 'w':
:185ga
      if (*bufp == 'e')
:c
        for (nlines = 0; fgets(lines[nlines], sizeof(*lines), fp); nlines++);
:i
      else
:180g20n
  180       break;
  181     case 'e':
  182     case 'w':
  183       fp = fopen(argv[1], *bufp == 'e' ? "r" : "w");
  184       if (fp == NULL)
  185         perror("fopen"), exit(EXIT_FAILURE);
  186       if (*bufp == 'e')
  187         for (nlines = 0; fgets(lines[nlines], sizeof(*lines), fp); nlines++);
  188       else
  189       if (fclose(fp) == EOF)
  190         perror("fclose"), exit(EXIT_FAILURE);
  191       break;
  192     case 'w':
  193       fp = fopen(argv[1], "w");
  194       if (fp == NULL)
  195         perror("fopen"), exit(EXIT_FAILURE);
  196       for (unsigned n = 0; n < nlines; n++)
  197         fputs(lines[n], fp);
  198       if (fclose(fp) == EOF)
  199         perror("fclose"), exit(EXIT_FAILURE);
:188g2a
        for (unsigned n = 0; n < nlines; fputs(lines[n++], fp));

:kd
:180g20n
  180       break;
  181     case 'e':
  182     case 'w':
  183       fp = fopen(argv[1], *bufp == 'e' ? "r" : "w");
  184       if (fp == NULL)
  185         perror("fopen"), exit(EXIT_FAILURE);
  186       if (*bufp == 'e')
  187         for (nlines = 0; fgets(lines[nlines], sizeof(*lines), fp); nlines++);
  188       else
  189         for (unsigned n = 0; n < nlines; fputs(lines[n++], fp));
  190       if (fclose(fp) == EOF)
  191         perror("fclose"), exit(EXIT_FAILURE);
  192       break;
  193     case 'w':
  194       fp = fopen(argv[1], "w");
  195       if (fp == NULL)
  196         perror("fopen"), exit(EXIT_FAILURE);
  197       for (unsigned n = 0; n < nlines; n++)
  198         fputs(lines[n], fp);
  199       if (fclose(fp) == EOF)
:193g9d190g20n
  190       if (fclose(fp) == EOF)
  191         perror("fclose"), exit(EXIT_FAILURE);
  192       break;
  193     case 'q':
  194       exit(EXIT_SUCCESS);
  195     }
  196 
  197     for (unsigned n = 0; n < cnt; n++) {
  198       switch (*bufp) {
  199       case 'a':
  200       case 'i':
  201       case 'c':
  202         fgets(lines[curr + n], sizeof(*lines), stdin);
  203         break;
  204       case 'n':
  205         if (*lines[curr + n])
  206           printf("\033[;2;3m%5u ", curr + n + 1); // 65536 is 5 chars long
  207       case 'p': {
  208         char *end = lines[curr + n];
  209         for (char *start = end; *start; start = end) {
:w
:197g40d190g20n
  190       if (fclose(fp) == EOF)
  191         perror("fclose"), exit(EXIT_FAILURE);
  192       break;
  193     case 'q':
  194       exit(EXIT_SUCCESS);
  195     }
  196 
  197     case 'p':
  198       curr += cnt;
  199       break;
  200     case 'k':
  201       curr -= cnt;
  202       break;
  203     case 'e':
  204     case 'w':
  205       if (fclose(fp) == EOF)
  206         perror("fclose"), exit(EXIT_FAILURE);
  207     }
  208 
  209     bufp++;
:197g12d190g20n
  190       if (fclose(fp) == EOF)
  191         perror("fclose"), exit(EXIT_FAILURE);
  192       break;
  193     case 'q':
  194       exit(EXIT_SUCCESS);
  195     }
  196 
  197     bufp++;
  198   }
  199 }
:wq
& make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
& bin/st2 st2.c
:180g20n
  180       break;
  181     case 'e':
  182     case 'w':
  183       fp = fopen(argv[1], *bufp == 'e' ? "r" : "w");
  184       if (fp == NULL)
  185         perror("fopen"), exit(EXIT_FAILURE);
  186       if (*bufp == 'e')
  187         for (nlines = 0; fgets(lines[nlines], sizeof(*lines), fp); nlines++);
  188       else
  189         for (unsigned n = 0; n < nlines; fputs(lines[n++], fp));
  190       if (fclose(fp) == EOF)
  191         perror("fclose"), exit(EXIT_FAILURE);
  192       break;
  193     case 'q':
  194       exit(EXIT_SUCCESS);
  195     }
  196 
  197     bufp++;
  198   }
  199 }
:183gpkc
      fp = fopen(argv[1], *bufp == 'e' ? "r" : "w");
      FILE *fp = fopen(argv[1], *bufp == 'e' ? "r" : "w");
:182gc
    case 'w': {
:192gc
    } break;
:134g2p2k
    FILE *fp = NULL;

:2d
:wq
& make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
& bin/st2 st2.c
:999n
    1 #include <stdio.h>
    2 #include <stdlib.h>
    3 #include <string.h>
    4 #include <ctype.h>
    5 
    6 // g - go to line number N
    7 // j - move down N lines
    8 // k - move up N lines
    9 // a - append N new lines below
   10 // i - insert N new lines above
   11 // c - rewrite next N lines
   12 // d - delete next N lines
   13 // y - yank (copy) next N lines
   14 // x - paste last yank N times
   15 // n - print next N lines numbered
   16 // p - print next N lines
   17 // e - read file from disk
   18 // w - write file to disk
   19 // q - quit without confirmation
   20 
   21 char *hi_default = "\033[m";
   22 char *hi_keyword = "\033[;1m";
   23 char *hi_comment = "\033[;2;3m";
   24 char *hi_operator = "\033[;2m";
   25 char *hi_literal = "\033[;3m";
   26 
   27 int isident(int c) { return c == '_' || isalnum(c); }
   28 char *hi_c(char **src) {
   29   static char *kws[] = {
   30     "auto", "break", "case", "char", "const", "continue",
   31     "default", "do", "double", "else", "enum", "extern",
   32     "float", "for", "goto", "if", "inline", "int",
   33     "long", "register", "restrict", "return", "short", "signed",
   34     "sizeof", "static", "struct", "switch", "typedef", "union",
   35     "unsigned", "void", "volatile", "while", "_Bool", "_Complex",
   36     "_Imaginary", NULL,
   37   };
   38   static char *pps[] = {
   39     "if", "elif", "else", "endif", "ifdef", "ifndef",
   40     "define", "undef", "include", "line", "error", "pragma",
   41     NULL,
   42   };
   43   static char *ops[] = {
   44     "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=",
   45     "^=", "<<=", ">>=", "++", "--", "+", "-", "*",
   46     "/", "%", "~", "&", "|", "^", "<<", ">>",
   47     "!", "&&", "||", "==", "!=", "<", ">", "<=",
   48     ">=", "[", "]", "->", ".", "(", ")", ",",
   49     "?", ":", "sizeof", NULL,
   50   };
   51 
   52   if (isspace(**src))
   53     return ++*src, hi_default;
   54 
   55   if (strncmp(*src, "//", 2) == 0) {
   56     while (**src && *++*src != '\n');
   57     return hi_comment;
   58   }
   59 
   60   for (char **kw = kws; *kw; kw++)
   61     if (strncmp(*src, *kw, strlen(*kw)) == 0)
   62       if (!isident((*src)[strlen(*kw)]))
   63         return *src += strlen(*kw), hi_keyword;
   64 
   65   if (isdigit(**src)) {
   66     while (isident(*++*src));
   67     return hi_literal;
   68   }
   69 
   70   if (isident(**src)) {
   71     while (isident(*++*src));
   72     return hi_default;
   73   }
   74 
   75   for (char **op = ops; *op; op++)
   76     if (strncmp(*src, *op, strlen(*op)) == 0)
   77       return *src += strlen(*op), hi_operator;
   78 
   79   if (**src == '"' || **src == '\'') {
   80     char quote = **src;
   81     while (**src && **src != '\n' && *++*src != quote)
   82       if (**src == '\\')
   83         ++*src;
   84     if (**src == quote)
   85       ++*src;
   86     return hi_literal;
   87   }
   88 
   89   if (**src == '#') {
   90     while (isspace(*++*src));
   91     for (char **pp = pps; *pp; pp++)
   92       if (strncmp(*src, *pp, strlen(*pp)) == 0)
   93         if (!isident((*src)[strlen(*pp)]))
   94           return *src += strlen(*pp), hi_keyword;
   95     return hi_default;
   96   }
   97 
   98   return ++*src, hi_default;
   99 }
  100 
  101 unsigned nlines = 0;
  102 char lines[65536][256] = {0};
  103 unsigned ncut = 0;
  104 char cut[256][256] = {0};
  105 
  106 int main(int argc, char **argv) {
  107   if (argc != 2)
  108     fputs("Usage: st2 <filename>\n", stdout), exit(EXIT_FAILURE);
  109 
  110   unsigned curr = 0;
  111   char buf[64] = "e\n";
  112   char *bufp = buf;
  113 
  114   while (!feof(stdin)) {
  115     if (*bufp == '\n') {
  116       fputs("\033[m:", stdout);
  117       bufp = fgets(buf, sizeof(buf), stdin);
  118       continue;
  119     }
  120 
  121     int nread;
  122     unsigned cnt;
  123     if (sscanf(bufp, "%u%n", &cnt, &nread) != 1)
  124       nread = 0, cnt = 1;
  125     bufp += nread;
  126 
  127     if (!strchr("gjkaicdyxnpewq", *bufp)) {
  128       printf("?\n");
  129       if (*bufp != '\n')
  130         bufp++;
  131       continue;
  132     }
  133 
  134     switch (*bufp) {
  135     case 'g':
  136       curr = cnt - 1;
  137       break;
  138     case 'j':
  139       curr += cnt;
  140       break;
  141     case 'k':
  142       curr -= cnt;
  143       break;
  144     case 'd':
  145       nlines -= cnt;
  146       memmove(lines[curr], lines[curr + cnt], (nlines - curr) * sizeof(*lines));
  147       memset(lines[nlines], 0, cnt * sizeof(*lines));
  148       break;
  149     case 'a':
  150       curr++;
  151     case 'i':
  152       memmove(lines[curr + cnt], lines[curr], (nlines - curr) * sizeof(*lines));
  153       nlines += cnt;
  154     case 'c':
  155       for (unsigned last = curr + cnt; curr < last; curr++)
  156         fgets(lines[curr], sizeof(*lines), stdin);
  157       break;
  158     case 'y':
  159       memcpy(*cut, lines[curr], (ncut = cnt) * sizeof(*cut));
  160       break;
  161     case 'x':
  162       memmove(lines[curr + cnt * ncut], lines[curr], (nlines - curr) * sizeof(*lines));
  163       nlines += cnt * ncut;
  164       for (unsigned last = curr + cnt * ncut; curr < last; curr += ncut)
  165         memcpy(lines[curr], *cut, ncut * sizeof(*cut));
  166       break;
  167     case 'n':
  168     case 'p':
  169       for (unsigned last = curr + cnt; curr < last; curr++) {
  170         if (*bufp == 'n' && *lines[curr])
  171           printf("\033[;2;3m%5u ", curr + 1); // 65536 is 5 chars long
  172         char *end = lines[curr];
  173         for (char *start = end; *start; start = end) {
  174           fputs(hi_c(&end), stdout);
  175           printf("%.*s", (int)(end - start), start);
  176         }
  177       }
  178       break;
  179     case 'e':
  180     case 'w': {
  181       FILE *fp = fopen(argv[1], *bufp == 'e' ? "r" : "w");
  182       if (fp == NULL)
  183         perror("fopen"), exit(EXIT_FAILURE);
  184       if (*bufp == 'e')
  185         for (nlines = 0; fgets(lines[nlines], sizeof(*lines), fp); nlines++);
  186       else
  187         for (unsigned n = 0; n < nlines; fputs(lines[n++], fp));
  188       if (fclose(fp) == EOF)
  189         perror("fclose"), exit(EXIT_FAILURE);
  190     } break;
  191     case 'q':
  192       exit(EXIT_SUCCESS);
  193     }
  194 
  195     bufp++;
  196   }
  197 }
:21gpkcpkcpkcpkcpkci
char *hi_default = "\033[m";
#define HI_DEFAULT "\033[m" // (reset)
char *hi_keyword = "\033[;1m";
#define HI_KEYWORD "\033[;1m" // bold
char *hi_comment = "\033[;2;3m";
#define HI_COMMENT "\033[;2;3m" // dim italic
char *hi_operator = "\033[;2m";
#define HI_OPERATOR "\033[;2m" // dim
char *hi_literal = "\033[;3m";
#define HI_LITERAL "\033[;3m" // italic
#define HI_LINENO "\033[;2;3m" // dim italic
:53gpkc
  if (isspace(**src))
  if (isspace(**src))
:54gpkc
    return ++*src, hi_default;
    return ++*src, HI_DEFAULT;
:58gpkc
    return hi_comment;
    return HI_COMMENT;
:64gpkc
        return *src += strlen(*kw), hi_keyword;
        return *src += strlen(*kw), HI_KEYWORD;
:68gpkc
    return hi_literal;
    return HI_LITERAL; 
:73gpkc
    return hi_default;
    return HI_DEFAULT;
:78gpkc
      return *src += strlen(*op), hi_operator;
      return *src += strlen(*op), HI_OPERATOR;
:87gpkc
    return hi_literal;
    return HI_LITERAL;
:95gpkc
          return *src += strlen(*pp), hi_keyword;
          return *src += strlen(*pp), HI_KEYWORD;
:pkc
    return hi_default;
    return HI_DEFAULT;
:99gpkc
  return ++*src, hi_default;
  return ++*src, HI_DEFAULT;
:117gpkc
      fputs("\033[m:", stdout);
      fputs(HI_DEFAULT ":", stdout);
:172gpkc
          printf("\033[;2;3m%5u ", curr + 1); // 65536 is 5 chars long
          printf(HI_LINENO "%5u ", curr + 1); // 65536 is 5 chars long
:wq
& bin/st2 st2.c
:59g7a

  if (strncmp(*src, "/*", 2) == 0) {
    while (*++*src && strncmp(*src, "*/", 2) != 0);
    if (**src) 
      *src += 2;
    return HI_COMMENT;
  }
:85g7jp
    if (**src == quote)
:kc
    if (**src)
:pkc
      ++*src;
      *src += 1;
:wq
& make st2
mkdir -p bin
gcc -O2 -Wall -Werror -pedantic -std=c99 st2.c -o bin/st2
&
